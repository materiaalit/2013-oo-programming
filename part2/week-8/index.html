<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>MOOC | MOOC - Massive online open course</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/styles.css" />

  <link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/mooc.cs.helsinki.fi/files/ctools/css/5c1587b6907a85bc361bd4b70014b0e3.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/system/system-menus.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/cck/theme/content-module.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/ckeditor/ckeditor.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/ctools/css/ctools.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/date/date.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/pan/css/panels.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/views/css/views.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/mooc.cs.helsinki.fi/files/ctools/css/aeb58e3ce47f9171327ad9fd87a26c8e.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/pan/plugins/layouts/flexible/flexible.css" />
    <script type="text/javascript" src="/2013-oo-programming/misc/jquery.js"></script>
<script type="text/javascript" src="/2013-oo-programming/misc/drupal.js"></script>
<script type="text/javascript" src="/2013-oo-programming/sites/all/modules/pan/js/panels.js"></script>
<script type="text/javascript">
<!--//--><![CDATA[//><!--
jQuery.extend(Drupal.settings, { "basePath": "/" });
//--><!]]>
</script>

<head>

<body id="pid-programming-part2-material-week-8" class="not-front not-logged-in page-node node-type-weekly-tasks no-sidebars full-node panels layout-main sidebars-both-first font-family-lucida font-size-13 grid-type-fluid grid-width-16 fluid-100">
  <div id="page" class="page">
    <div id="page-inner" class="page-inner">

      <!-- header-top row: width = grid_width -->

      <!-- header-group row: width = grid_width -->
      <div id="header-group-wrapper" class="header-group-wrapper full-width">
        <div id="header-group" class="header-group row grid16-16">
          <div id="header-group-inner" class="header-group-inner inner clearfix">
                                    <div id="primary-menu" class="primary-menu block">
<div id="primary-menu-inner" class="primary-menu-inner inner clearfix">
    <div class="navigation-wrapper"> <div class="navigation-links left">
        <a href="http://mooc.fi/english.html" title="Courses">Courses</a>
        <a href="../week-7">Week 7</a>
        <a class="not-active">Week 8</a>
        <a href="../week-9">Week 9</a>
        <a href="../week-10">Week 10</a>
        <a href="../week-11">Week 11</a>
        <a href="../week-12">Week 12</a>
      </div>
<div class="navigation-links right">                     <a href="https://riot.im/app/#/room/#mooc.fi:matrix.org">Chat</a>                 </div>                 </div> </div><!-- /primary-menu-inner -->
</div><!-- /primary-menu -->
          </div><!-- /header-group-inner -->
        </div><!-- /header-group -->
      </div><!-- /header-group-wrapper -->

      <!-- preface-top row: width = grid_width -->

<!--            <div id="preface-top-wrapper" class="preface-top-wrapper full-width">
        <div id="preface-top" class="preface-top row grid16-16">
          <div id="preface-top-inner" class="preface-top-inner inner clearfix">
-->
          </div><!-- /preface-top-inner -->
        </div><!-- /preface-top -->
      </div><!-- /preface-top-wrapper -->

    <!-- main row: width = grid_width -->
    <div id="main-wrapper" class="main-wrapper full-width">
      <div id="main" class="main row grid16-16">
        <div id="main-inner" class="main-inner inner clearfix">

          <!-- main group: width = grid_width - sidebar_first_width -->
          <div id="main-group" class="main-group row nested grid16-16">
            <div id="main-group-inner" class="main-group-inner inner clearfix">

              <div id="main-content" class="main-content row nested">
                <div id="main-content-inner" class="main-content-inner inner clearfix">
                  <!-- content group: width = grid_width - (sidebar_first_width + sidebar_last_width) -->
                    <div id="content-group" class="content-group row nested " style="width:100%">
                      <div id="content-group-inner" class="content-group-inner inner clearfix">


                        <div id="content-region" class="content-region row nested">
                          <div id="content-region-inner" class="content-region-inner inner clearfix">
                            <a name="main-content-area" id="main-content-area"></a>
                                                        <div id="content-inner" class="content-inner block">
                              <div id="content-inner-inner" class="content-inner-inner inner clearfix">
                                                                                                <div id="content-content" class="content-content">
                                  <div class="panel-flexible panels-flexible-13 clear-block" >
<div class="panel-flexible-inside panels-flexible-13-inside">
<div class="panels-flexible-row panels-flexible-row-13-7 panels-flexible-row-first clear-block ">
  <div class="inside panels-flexible-row-inside panels-flexible-row-13-7-inside panels-flexible-row-inside-first clear-block">
<div class="panels-flexible-region panels-flexible-region-13-js_ panels-flexible-region-first panels-flexible-region-last ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js_-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<div class="panel-pane pane-custom pane-2 " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">

            <div class="warning-banner">
  <h3>
    A new version of this course is available here:
    <br>
    <a href="https://java-programming.mooc.fi/">https://java-programming.mooc.fi/</a>
  </h3>
</div>

<div class="warning-banner-yellow">
  <h3>Warning: This course has migrated to a new server <a href="https://tmc.mooc.fi">https://tmc.mooc.fi</a> (Only affects people using the server <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a>) <br>
    What this means:</h3>
  <ul>
    <li>Old accounts at <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a> will not work anymore. You have to create a new account at <a href="https://tmc.mooc.fi/user/new">https://tmc.mooc.fi</a>.</li>
    <li>Old submissions at <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a> will not be migrated to the new server. Theywill still be visible at the old server for now.</li>
    <li>The old server <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a> will be shut down at some point next year, but there is a brand new Object-Oriented Programming with Java course coming up! This course is just a placeholder between the old and the new course.</li>
    <li>This placeholder course is found at <a href="https://tmc.mooc.fi/org/mooc">https://tmc.mooc.fi/org/mooc</a>. Notice the /org/ part in the middle.</li>
    <li>If you were doing the course on the old server and want to continue where you left off there, please resubmit all your exercises to the new server.</li>
    <li>Remember to change your account name, password and server address in Netbeans' TMC Settings to correspond the account you have on the new server. The correct server address is "https://tmc.mooc.fi/org/mooc".</li>
</ul>
</div>

                    <div class="pane-content content">
                      <h1 class="title">Object-Oriented Programming with Java, part II</h1>        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --><div class="panel-region-separator"></div><div class="panel-pane pane-custom pane-3 " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <link href="/2013-oo-programming/menu.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/2013-oo-programming/common-new.css" media="screen, print" rel="stylesheet" type="text/css" />
<link href="/2013-oo-programming/sh_style.css" media="screen, print" rel="stylesheet" type="text/css" />        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
  </div>
</div>
<div class="panels-flexible-row panels-flexible-row-13-4 clear-block js">
  <div class="inside panels-flexible-row-inside panels-flexible-row-13-4-inside clear-block">
<div class="panels-flexible-region panels-flexible-region-13-js_en_ panels-flexible-region-first ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js_en_-inside panels-flexible-region-inside-first">
  </div>
</div>
<div class="panels-flexible-region panels-flexible-region-13-js ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js-inside">
<div class="panel-pane pane-node " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">

<div id="node-222" class="node odd full-node node-type-page">
  <div class="inner">

        <h2 class="title"><a href="/content/js-en" title=""></a></h2>



    <div class="content clearfix">
      <script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/materiaali/javascripts/exercises-eng-new.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/materiaali/javascripts/common-mooc-eng.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/shjs/sh_main.min.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/shjs/sh_java.min.js"></script>



<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/jquery.easing.js"></script>

<div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="1">
          <!-- <span id="materiaali_toc" ></span> -->
          <!--div id="tehtavat_toc" ></div-->
          <!-- <span id="tehtavat_toc2" ></span> -->
        </div>    </div>


      </div><!-- /inner -->

  </div><!-- /node-222 -->
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
<div class="panels-flexible-region panels-flexible-region-13-copyright panels-flexible-region-last float-right">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-copyright-inside panels-flexible-region-inside-last">
<div class="panel-pane pane-custom pane-1 box " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:right;" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a><small>This material is licensed under the Creative Commons BY-NC-SA license, which means that you can use it and distribute it freely so long as you do not erase the names of the original authors. If you do changes in the material and want to distribute this altered version of the material, you have to license it with a similar free license. The use of the material for commercial use is prohibited without a separate agreement.</small></p>        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --><div class="panel-region-separator"></div><div class="panel-pane pane-content-field pane-field-author course-menu " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <div class="field field-type-text field-field-author">
    <div class="field-items">
            <div class="field-item odd">
                    Authors: Arto Hellas, Matti Luukkainen        </div>
        </div>
</div>
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --><div class="panel-region-separator"></div><div class="panel-pane pane-content-field pane-field-translators course-menu " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <div class="field field-type-text field-field-translators">
    <div class="field-items">
            <div class="field-item odd">
                    Translators: Simone Romeo, Kenny Heinonen        </div>
        </div>
        <div class="field-item odd"><br>The course is maintained by the Agile Education Research Group</div>
</div>
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
  </div>
</div>
<div class="panels-flexible-row panels-flexible-row-13-8 panels-flexible-row-last clear-block js en">
  <div class="inside panels-flexible-row-inside panels-flexible-row-13-8-inside panels-flexible-row-inside-last clear-block">
<div class="panels-flexible-region panels-flexible-region-13-js_en panels-flexible-region-first panels-flexible-region-last ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js_en-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<div class="panel-pane pane-node-content box-mooc " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">

<div id="node-312" class="node even full-node node-type-weekly_tasks">
  <div class="inner">




    <div class="content clearfix">
      <div class="viikkoraja-mooc" id="Week 8" deadline="unlocks when 85% of week 7 done " data-first-chapter-index="38" data-first-exercise-index="116" data-first-week-index="8" data-first-chapter-index-mooc="39" data-first-exercise-index-mooc="9" data-first-week-index-mooc="8" tekija="Arto Vihavainen, Matti Luukkainen">


            <h2 id="object">Object</h2>

            <p>In our course, we have been using frequently the method <code>public String toString()</code> when we wanted to print an object in the shape of a string. Calling the method without setting it up properly does usually cause an error. We can have a look at the class <code>Book</code>, which does not contain the method <code>public String toString()</code> yet, and see what happens when the program uses the method <code>System.out.println()</code> and tries to print an object of <code>Book</code> class.</p>

            <pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }
}
            </pre>

            <pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
            </pre>

            <p>if we take an object of <code>Book</code> class and use it as the parameter of the method <code>System.out.println()</code>, our program does not print an error message. Our program does not crash, and instead of reading an error message, we notice an interesting print output. The print output contains the name of the class, <code>Book</code>, plus an indefinite String which follows a @ character. Notice that when we call <code>System.out.println(objectBook)</code> Java calls <code>System.out.println(objectBook.toString())</code>, in fact, but this does not cause an error.</p>

            <p>The explanation is related to the way Java classes are built. Each Java class automatically <em>inherits</em> the <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code> class, which contains a set of methods that are useful to each Java class. Heritage means that our class has access to the features and functions defined in the inherited class. Among the others, the class <code>Object</code> contains the method <code>toString</code>, which is inherited by the classes we create.</p>

            <p>The <code>toString</code> method inherited from the object class is not usually the one we'd want. That's why we will want to <em>replace</em> it with one we make personally. Let us add the method <code>public String toString()</code> to our <code>Book</code> class. This method will replace the <code>toString</code> method inherited from the <code>Object</code> class.</p>

            <pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }
}
            </pre>

            <p>If now we create an object instance, and we set it into the print method, we notice that the <code>toString</code> method of the <code>Book</code> class produces a string.</p>

            <pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
            </pre>

            <pre>
Object book (2000)
            </pre>

            <p>Above the <code>toString</code> method of class <code>Book</code> we see the <code>@Override</code> <em>annotation</em>. We use annotations to give guidelines to both the translator and the reader about how to relate to the methods. The <code>@Override</code> annotation tells that the following method replaces the one defined inside the inherited class. If we don't add an annotation to the method we replace, the translator gives us a <em>warning</em>, however avoiding writing annotations is not a mistake.</p>

            <p>There are also other useful methods we inherit from the <code>Object</code> class. Let us now get acquainted with the methods <code>equals</code> and <code>hashCode</code>.</p>

            <h3>Equals Method</h3>

            <p>The <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code> method is used to compare two objects. The method is particularly used when we compare two <code>String</code> objects.</p>

            <pre class="sh_java">
Scanner reader = new Scanner(System.in);

System.out.print("Write password: ");
String password = reader.nextLine();

if (password.equals("password")) {
    System.out.println("Right!");
} else {
    System.out.println("Wrong!");
}
            </pre>

            <pre>
Write password: <font color="red">mightycarrot</font>
Wrong!
            </pre>

            <p>The <code>equals</code> method is defined in the <code>Object</code> class, and it makes sure that both the parameter object and the compared object have the same reference. In other words, by default the method makes sure that we are dealing with <em>one</em> unique object. If the reference is the same, the method returns <code>true</code>, otherwise <code>false</code>. The following example should clarify the concept. The class <code>Book</code> doesn't implement its own <code>equals</code> method, and therefore it uses the one created by the <code>Object</code> class.</p>

            <pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = objectBook;

if (objectBook.equals(objectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}

// Now we create an object with the same contents, which is however a different, independent object
anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}
            </pre>

            <p>Print output:</p>

            <pre>
The books were the same
The books were not the same
            </pre>

            <p>Even if the internal structure of both <code>Book</code> objects (i.e. the object variable values) is exactly the same, only the first comparison prints "<code>The books were the same</code>". This depends on the fact that only in the first case also the references were the same, i.e. we were comparing an object with itself. In the second example, we had two different objects even though they both had the same values.</p>

            <p>When we use the <code>equals</code> method to compare strings, it works as we want it to: it identifies two strings as equal if the have the same <em>contents</em> even though they are two different objects. In fact, the default <code>equals</code> method is replaced with a new implementation in the String class.</p>

            <p>We want that book comparison happened against name and year. We replace the <code>equals</code> method in the <code>Object</code> class with an implementation in the <code>Book</code> class. The <code>equals</code> method has to make sure whether the object is the same as the one received as parameter. First, we define a method according to which all the objects are the same.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        return true;
    }
            </pre>

            <p>Our method is a little too optimistic, so let us change its functionality slightly. Let us define that the objects are not the same if the parameter object is <em>null</em> or if the the two object types are different. We can find out the type of an object with the method <code>getClass()</code> (which is denifed in the <code>oject</code> class). Otherwise, we expect that the objects are the same.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (this.getClass() != object.getClass()) {
            return false;
        }

        return true;
    }
            </pre>

            <p>The <code>equals</code>method finds out the class difference of two objects, but it is not able to distinguish two similar objects from each other. In order to compare our object with the object we received as parameter, and whose reference is <code>Object</code> type, we have to change the type of the Object reference. The reference type can be changed if and only if the object type is really such as we are converting it into. Type casting happens by specifying the desired class within brackets on the right side of the assignment sentence:</p>

            <pre class="sh_java">
    WantedType variable = (WantedType) oldVariable;
            </pre>

            <p>Type casting is possible because we know two objects are the same type. If they are different type, the above <code>getClass</code> method returns false. Let us change the <code>Object</code> parameter received with the <code>equals</code> method into <code>Book</code> type, and let us identify two different books against their publishing year. The books are otherwise the same.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if(this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        return true;
    }
            </pre>

            <p>Now, our comparison method is able to distinguish books against their publishing year. Wa want to check still that our book names are the same, and our own book name is not <em>null</em>.</p>

            <pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
            </pre>

            <p>Excellent, we have got a method for comparison which works, finally! Below is our <code>Book</code> class as it looks like at the moment.</p>

            <pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
}
            </pre>

            <p>Now, our book comparison returns <code>true</code>, if the book contents are the same.</p>

            <pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books are the same");
} else {
    System.out.println("The books are not the same");
}
            </pre>

            <pre>
The books are the same
            </pre>

            <h4>Equals and ArrayList</h4>

            <p>Various different Java made-up methods make use of the <code>equals</code> method to implement their search functionality. For instance, the <code>contains</code> mehod of class <code>ArrayList</code> compares objects through the <code>equals</code> method. Let us continue to use the <code>Book</code> class we defied for our examples. If our objects do not implement the <code>equals</code> method, we can't use the <code>contains</code> method, for instance. Try out the code below in two different <code>book</code> classes. The first class implements the <code>equals</code> method, the other does not.</p>

            <pre class="sh_java">
ArrayList&lt;Book&gt; books = new ArrayList&lt;Book&gt;();
Book objectBook = new Book("Objectbook", 2000);
books.add(objectBook);

if (books.contains(objectBook)) {
    System.out.println("The object book was found.");
}

objectBook = new Book("Objectbook", 2000);

if (!books.contains(objectBook)) {
    System.out.println("The object book was not found.");
}
            </pre>

            <h3>HashCode Method</h3>

            <p>The <code>hashCode</code> method takes an object and returns a numeric value, i.e. a hash value. We need numeric values for instance when we use and object as HashMap keys. So far, we have been using only String and Integer objects as HashMap keys, and their <code>hashCode</code> method is implemented by default. Let us make an example where it is not so: let us continue with our book examples and let us start to take note of our books on loan. We want to implement our bookkeeping through Hashmap. The key is the book, and the book's value is a string, which tells the loaner's name:</p>

            <pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();

        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );

        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
            </pre>

            <p>Print output:</p>

            <pre>
Pekka
null
null
            </pre>

            <p>We can find the loaner by searching against the same object which was given as HashMap key with the <code>put</code> method. However, if our search item is the same book but a different object, we are not able to find its loaner and we are retured with a <em>null</em> reference. This is again due to the default implementation of the <code>hashCode</code> method of <code>Object</code> class. The default implementation creates an index based on the reference; this means that different objects with the same content receive different hashCode method outputs, and therefore it is not possible to find the right place of the object in the HashMap.</p>

            <p>To be sure the HashMap worked in the way we want - i.e. it returned the loaner when the key is an object with the right <em>content</em> (not necessarily the same object as the original value) - the class which works as key must overwrite both the <code>equals</code> method and the <code>hashCode</code> method. The method must be overwritten in such a way, so that it would assign the same numeric value to all objects which have the same content. Some objects with different content may eventually be assigned the same hashCode; however, different content objects should be assigned the same hashCode as rarely as possible, if we want our HashMap to be efficient.</p>

            <p>Previously, we have successfully used <code>String</code> objects as HashMap keys, and we can therefore say that the <code>String</code> class has a <code>hashCode</code> implementation which works as expected. Let us <em>delegate</em> the calculation to the <code>String</code> object.</p>

            <pre class="sh_java">
    public int hashCode() {
        return this.name.hashCode();
    }
            </pre>

            <p>The solution above is quite good; but if <code>name</code> is <em>null</em>, we are thrown a <code>NullPointerException</code>. We can fix this by setting the condition: if the value of the <code>name</code> variable is is <em>null</em>, return value 7. Seven is a value chosen casually, thirteen could have done as well.</p>

            <pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.name.hashCode();
    }
            </pre>

            <p>We can still improve the <code>hashCode</code> method by taking into consideration the book publishing year, in our calculations:</p>

            <pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
            </pre>


            <p>An additional remark: the output of the hashCode method of HashMap key objects tells us their value slot in the hash construction, i.e. their index in the HashMap. You may now be wondering: "doesn't this lead to a situation where more than one object ends up with the same index in the HashMap?". The answer is yes and no. Even if the <code>hashCode</code> method gave the same value to two different objects, HashMaps are built in such way that various different obejcts may have the same index. In order to distinguish objects with the same index, the key objects of the HashMap must have implemented the <code>equals</code> method. You will find more information about Hashmap implementation in the course <em>Data Structures and Algorithms</em>.</p>

            <p>The final <code>Book</code> class now.</p>

            <pre class="sh_java">
public class Book {

    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
}
            </pre>

            <p><b>Let us sum up everything again:</b> in order to use a class as HashMap key, we have to define</p>
            <ul><li>The <code>equals</code> method in a way that objects with the same content will return true when compared, whereas different-content objects shall return false</li>
              <li>The <code>hashCode</code> method in a way that it assigns the same value to all the objects whose content is regarded as similar</li>
            </ul><p>The equals and hashCode methods of our Book class fulfill these two conditions. Now, the problem we faced before is solved, and we can find out the book loaners:</p>

            <pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();

        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );

        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
            </pre>

            <p>Print output:</p>

            <pre>
Pekka
Pekka
Arto
            </pre>

            <p><em>NetBeans allows for the automatic creation of the <code>equals</code> and <code>hashCode</code> methods. From the menu Source -&gt; Insert Code, you can choose <em>equals() and hashCode()</em>. After this, NetBeans asks which object variables the methods shall use.</em></p>

            <nextweek/><div class="tehtavat" id="viikko8">
              <div class="tehtava">



                <h3>Car Registration Centre</h3>

                <h4>Registration Plate Equals and HashCode</h4>

                <p>European registration plates are composed of two parts: the country ID -- one or two letters long -- and possibly a regitration code specific for the country, which in turn is composed of numbers and letters. Registaration plates are defined using the following class:</p>

                <pre class="sh_java">
public class RegistrationPlate {
    // ATTENTION: the object variable types are final, meaning that their value cannot be changed!
    private final String regCode;
    private final String country;

    public RegistrationPlate(String regCode, String country) {
       this.regCode = regCode;
       this.country = country;
    }

    public String toString(){
        return country+ " "+regCode;
    }
}
                </pre>

                <p>We want to store the registration plates into say ArrayLists, using a HashMap as key. As mentioned before, it means we have to implement the methods <code>equals</code> and <code>hashCode</code> in their class, otherwise they can't work as we want. </p>

                <p><strong>Suggestion:</strong> take the equals and hashCode models from the Book example above. The registration plate hashCode can be created say combining the hashCodes of the country ID and of the registration code.</p>

                <p>Example program:</p>

                <pre class="sh_java">
    public static void main(String[] args) {
        RegistrationPlate reg1 = new RegistrationPlate("FI", "ABC-123");
        RegistrationPlate reg2 = new RegistrationPlate("FI", "UXE-465");
        RegistrationPlate reg3 = new RegistrationPlate("D", "B WQ-431");

        ArrayList&lt;RegistrationPlate&gt; finnish = new ArrayList&lt;RegistrationPlate&gt;();
        finnish.add(reg1);
        finnish.add(reg2);

        RegistrationPlate new = new RegistrationPlate("FI", "ABC-123");
        if (!finnish.contains(new)) {
            finnish.add(new);
        }
        System.out.println("Finnish: " + finnish);
        // if the equals method hasn't been overwritten, the same registration plate is repeated in the list

        HashMap&lt;RegistrationPlate, String&gt; owners = new HashMap&lt;RegistrationPlate, String&gt;();
        owners.put(reg1, "Arto");
        owners.put(reg3, "Jürgen");

        System.out.println("owners:");
        System.out.println(owners.get(new RegistrationPlate("FI", "ABC-123")));
        System.out.println(owners.get(new RegistrationPlate("D", "B WQ-431")));
        // if the hashCode hasn't been overwritten, the owners are not found
    }
                </pre>

                <p>If equals hashCode have been implemented well, the output should look like this:</p>

                <pre>
Finnish: [FI ABC-123, FI UXE-465]
owners:
Arto
Jürgen

                </pre>

                <h4>The Owner, Based of the Registration Plate</h4>

                <p>Implement the class <code>VehicleRegister</code> which has the following methods:</p>

                <ul><li><code>public boolean add(RegistrationPlate plate, String owner)</code>, which adds the parameter owner of the car which corresponds to the parameter registration plate. The method returns true if the car had no owner; if the car had an owner already, the method returns false and it doesn't do anything</li>
                  <li><code>public String get(RegistrationPlate plate)</code>, which returns the car owner which corresponds to the parameter register number. If the car was not registered, it returns <code>null</code></li>
                  <li><code>public boolean delete(RegistrationPlate plate)</code>, which delete the information connected to the parameter registration plate. The method returns true if the information was deleted, and false if there was no information connetted to the parameter in the register.</li>
                </ul><p><strong>Attention:</strong> the vehicle register has to store the owner information into a <code>HashMap&lt;RegistrationPlate, String&gt; owners</code> object variable!</p>

                <h4>More for the Vehicle Register</h4>

                <p>Add still the following methods to your VehicleRegister:</p>

                <ul><li><code>public void printRegistrationPlates()</code>, which prints out all the registration plates stored</li>
                  <li><code>public void printOwners()</code>, which prints all the car owners stored. Each owner's name has to be printed only once, even though they had more than one car</li>
                </ul></div>
            </div>
            <h2 id="rajapinta">Interface</h2>

            <p><em>Interface</em> is an instrument we have to define the functionality our classes should have. Interfaces are defined as normal Java classes, but instead of the definition "<code>public class ...</code>", we write "<code>public interface ...</code>". The interfaces influence class behaviour by defining the method names and return values, but they <em>do not contain method implementation</em>. The access modifier is not specified, because it is always <code>public</code>. Let us have a look at the interface <em>Readable</em>, which defines whether an object can be read.</p>

            <pre class="sh_java">
public interface Readable {
    String read();
}
            </pre>

            <p>The interface <code>Readable</code> defines the method <code>read()</code>, which returns a string object. The classes which implement an interface decide <em>in which way</em> the methods defined in the interface have to be implemented, in the end. A class implements an interface by adding the keyword <em>implements</em> between the class and the interface name. Below, we create the class <code>SMS</code> which implements <code>Readable</code> interface.</p>

            <pre class="sh_java">
public class SMS implements Readable {
    private String sender;
    private String content;

    public SMS(String sender, String content) {
        this.sender = sender;
        this.content = content;
    }

    public String getSender() {
        return this.sender;
    }

    public String read() {
        return this.content;
    }
}
            </pre>

            <p>Because the class <code>SMS</code> implements the interface <code>Readable</code> (<code>public class SMS implements Readable</code>), the class <code>SMS</code> <em>must</em> implement the method <code>public String read()</code>. The implementations of methods defined in the interface must always have public access.</p>

            <p><em>An interface is a behavioural agreement. In order to implement the behaviour, the class must implement the methods defined by the interface. The programmer of a class which implements an interface has to define what the behaviour will be like. Implementing an interface means to agree that the class will offer all the actions defined by the interface, i.e. the behaviour defined by the interface. A class which implements an interface but does not implement some of the interface methods can not exist.</em></p>

            <p>Let us implement another class which implements the <code>Readable</code> interface, in addition to our <code>SMS</code> class. The class <code>EBook</code> is the electronic implementation of a book, and it contains the book name and page number. The EBook reads one page at time, and the <code>public String read()</code> method always returns the string of the following page.</p>

            <pre class="sh_java">
public class EBook implements Readable {
    private String name;
    private ArrayList&lt;String&gt; pages;
    private int pageNumber;

    public EBook(String name, ArrayList&lt;String&gt; pages) {
        this.name = name;
        this.pages = pages;
        this.pageNumber = 0;
    }

    public String getName() {
        return this.name;
    }

    public int howManyPages() {
        return this.pages.size();
    }

    public String read() {
        String page = this.pages.get(this.pageNumber);
        nextPage();
        return page;
    }

    private void nextPage() {
        this.pageNumber = this.pageNumber + 1;
        if(this.pageNumber % this.pages.size() == 0) {
            this.pageNumber = 0;
        }
    }
}
            </pre>

            <p>Classes which implement interfaces generate objects as well as normal classes, and they can be used as ArrayList types too.</p>

            <pre class="sh_java">
    SMS message = new SMS("ope", "Awesome stuff!");
    System.out.println(message.read());

    ArrayList&lt;SMS&gt; messages = new ArrayList&lt;SMS&gt;();
    messages.add(new SMS("unknown number", "I hid the body.");
            </pre>

            <pre>Awesome stuff!</pre>

            <pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("Split your method into short clear chunks.");
    pages.add("Devide the user interface logic from the application logic.");
    pages.add("At first, always code only a small program which solves only a part of the problem.");
    pages.add("Practice makes perfect. Make up your own fun project.");

    EBook book = new EBook("Programming Hints.", pages);
    for(int page = 0; page &lt; book.howManyPages(); page++) {
        System.out.println(book.read());
    }
            </pre>

            <pre>

Split your method into short clear chunks.
Divide the user interface logic from the application logic.
At first, always code only a small program which solves only a part of the problem.
Practice makes perfect. Make up your own fun project.
            </pre>

            <div class="tehtavat">
              <div class="tehtava">

                <h3>NationalService</h3>

                <p>In the exercise layout, you find the premade interface <code>NationalService</code>, which contains the following operations:</p>

                <ul><li> the method <code>int getDaysLeft()</code> which returns the number of days left on service</li>
                  <li> the method <code>void work()</code>, which reduces the working days by one. The working days number can not become negative.</li>
                </ul><pre class="sh_java">
public interface NationalService {
    int getDaysLeft();
    void work();
}
                </pre>

                <h4>CivilService</h4>

                <p>Create the class <code>CivilService</code> which implements your <code>NationalService</code> interface. The class constructor is without parameter. The class has the object variable daysLeft which is initialised in the constructor receiving the value 362.</p>

                <h4>MilitaryService</h4>

                <p>Create the class <code>MilitaryService</code> which implements your <code>NationalService</code> interface. The class constructor has one parameter, defining the days of service (<code>int daysLeft</code>).</p>
              </div>
            </div>

            <h3>An Interface as Variable Type</h3>

            <p>When we create a new variable we always specify its type. There are two types of variable types: primitive-type variables (int, double, ...) and reference-type (all objects). As far as reference-type variables are concerned, their class has also been their type, so far.</p>

            <pre class="sh_java">
    String string = "string-object";
    SMS message = new SMS("teacher", "Something crazy is going to happen");
            </pre>

            <p>The type of an object can be different from its class. For instance, if a class implements the interface <code>Readable</code>, its type is <code>Readable</code>, too. For instance, since the class <code>SMS</code> implements the interface <code>Readable</code>, it has two types: <code>SMS</code> and <code>Readable</code>.</p>

            <pre class="sh_java">
    SMS message = new SMS("teacher", "Awesome stuff!");
    Readable readable = new SMS("teacher", "The SMS is Readable!");
            </pre>

            <pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("A method can call itself.");

    Readable book = new EBook("Recursion Principles", pages);
    for(int page = 0; page &lt; ((EBook)book).howManyPages(); page++) {
        System.out.println(book.read());
    }
            </pre>

            <p>Because an interface can be used as type, it is possible to create a list containing interface-type objects.</p>

            <pre class="sh_java">
    ArrayList&lt;Readable&gt; numberList = new ArrayList&lt;Readable&gt;();

    numberList.add(new SMS("teacher", "never been programming before..."));
    numberList.add(new SMS("teacher", "gonna love it i think!"));
    numberList.add(new SMS("teacher", "give me something more challenging! :)"));
    numberList.add(new SMS("teacher", "you think i can do it?"));
    numberList.add(new SMS("teacher", "up here we send several messages each day"));

    for (Readable readable: numberList) {
        System.out.println(readable.read());
    }
            </pre>

            <p>The <code>EBook</code> class implements the interface <code>Readable</code>. However, notice that even though the type of the class <code>EBook</code> is an interface, <code>EBook</code> is not the type of all the classes which implement the <code>Readable</code> interface. It is possible to assign an <code>EBook</code> object to a <code>Readable</code> variable, but the assignment does not work in the opposite way without a particular type change.</p>

            <pre class="sh_java">
    Readable readable = new SMS("teacher", "The SMS is Readable!"); // works
    SMS message = readable; // not possible

    SMS transformedMessage = (SMS) readable; // works
            </pre>

            <p>Type casting works if and only if the variable's type is really what we try to change it into. Type casting is not usually a best practice; one of the only cases where that is legitimate is in connection with the <code>equals</code> method.</p>

            <h3>An Interface as Method Parameter</h3>

            <p>The real use of interfaces becomes clear when we use them for the type of a method parameter. Because interfaces can be used as variable type, they can be used in method calls as parameter type. For instance, the below method <code>print</code> of class <code>Printer</code> receives a <code>Readable</code> variable.</p>

          <pre class="sh_java">
public class Printer {
    public void print(Readable readable) {
        System.out.println(readable.read());
    }
}
          </pre>

          <p>The real value of the <code>print</code> method of class <code>Printer</code> is that its parameter can be <em>whatever</em> class instance which implements our <code>Readable</code> interface. When we call the method of an object, the method will work regardless of the class of this object, as long as the object implements Readable.</p>

          <pre class="sh_java">
    SMS message = new SMS("teacher", "Wow, this printer is able to print them, actually!");
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.");

    EBook book = new EBook("Introduction to University Mathematics.", pages);

    Printer printer = new Printer();
    printer.print(message);
    printer.print(book);
          </pre>

          <pre>
Wow, this printer is able to print them, actually!
{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.
          </pre>

          <p>Let us implement another <code>numberList</code> class, where we can add interesting readable stuff. The class has an <code>ArrayList</code> instance as object variable where we save things to read. We add items to our number list through the <code>add</code> method which receives a <code>Readable</code> variable as parameter.</p>

          <pre class="sh_java">
public class NumberList {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }
}
          </pre>

          <p>Number lists are usually readable, so we can implement the <code>Readable</code> interface to the <code>NumberList</code> class. The number list <code>read</code> method reads all the objects of the <code>readables</code> list, and it adds them one by one to a string which is returned by the <code>read()</code> method.</p>

          <pre class="sh_java">
public class NumberList implements Readable {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }

    public String read() {
        String read = "";
        for(Readable readable: this.readables) {
            read += readable.read() + "\n";
        }

        this.readables.clear();
        return read;
    }
}
          </pre>

          <pre class="sh_java">
    NumberList joelList = new NumberList();
    joelList.add(new SMS("matti", "have you already written the tests?"));
    joelList.add(new SMS("matti", "did you have a look at the submissions?"));

    System.out.println("Joel has " + joelList.howManyReadables() + " messages to read");
          </pre>

          <pre>
Joel has got 2 messages to read
          </pre>

          <p>Because the type of <code>NumberList</code> is <code>Readable</code>, we can add <code>NumberList</code> objects to our number list, too. In the example below, Joel has a lot of messages to read, luckily Mikael deals with it and reads the messages on behalf of Joel.</p>

          <pre class="sh_java">
    NumberList joelList = new NumberList();
    for (int i = 0; i &lt; 1000; i++) {
        joelList.add(new SMS("matti", "have you already written the tests?"));
    }

    System.out.println("Joel has " + joelList.howManyReadables() + " messages to read");
    System.out.println("Let's delegate some reading to Mikael");

    NumberList mikaelList = new NumberList();
    mikaelList.add(joelList);
    mikaelList.read();

    System.out.println();
    System.out.println("Joel has " + joelList.howManyReadables() + " messages to read");
          </pre>

          <pre>
Joel has 1000 messages to read
Let's delegate some reading to Mikael

Joel has 0 messages to read
          </pre>

          <p>The <code>read</code> method which is called in connection to Mikael's list parses all the <code>Readable</code> objects contained in the list, and calls their <code>read</code> method. At the end of each <code>read</code> method call the list is cleared. In other words, Joel's number list is cleared as soon as Mikael reads it.</p>

        <p><em>At this point, there are a lot of references; it would be good to draw down the objects and try to grasp how the <code>read</code> method call connected to <code>mikaelList</code> works!</em></p>

        <div class="tehtavat">
          <div class="tehtava">

            <h3>Boxes and Things</h3>

            <h4 class="req">ToBeStored</h4>

            <p>We need storage boxes when we move to a new apartment. The boxes are used to store different things. All the things which are stored in the boxes have to implement the following interface:</p>

            <pre class="sh_java">
public interface ToBeStored {
    double weight();
}
            </pre>

            <p>Add the interface to your program. New interfaces are added almost in the same way as classes: you choose <i>new Java interface</i> instead of <i>new Java class</i>.</p>

            <p>Create two classes which implement the interface <code>Book</code> and <code>CD</code>. Book receives its writer (String), name (String), and weight (double), all as parameter. CD's parameter contains its artist (String), title (String), and publishing year (int). All CDs weigh 0.1 kg.</p>

            <p>Remember that the classes also have to implement the interface <code>ToBeStored</code>. The classes have to work in the following way:</p>

            <pre class="sh_java">
    public static void main(String[] args) {
        Book book1 = new Book("Fedor Dostojevski", "Crime and Punishment", 2);
        Book book2 = new Book("Robert Martin", "Clean Code", 1);
        Book book3 = new Book("Kent Beck", "Test Driven Development", 0.5);

        CD cd1 = new CD("Pink Floyd", "Dark Side of the Moon", 1973);
        CD cd2 = new CD("Wigwam", "Nuclear Nightclub", 1975);
        CD cd3 = new CD("Rendezvous Park", "Closer to Being Here", 2012);

        System.out.println(book1);
        System.out.println(book2);
        System.out.println(book3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
            </pre>

            <p>Print output:</p>

            <pre>
Fedor Dostojevski: Crime and Punishment
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
            </pre>

            <p>Attention! The weight is not reported here.</p>

            <h4 class="req">Box</h4>

            <p>Create the class box, which has to store Things that implement the interface <code>ToBeStored</code>. The box receives as constructor the maximum weight, expressed in kilograms. The box can't be added more things than its maximum capacity allows for. The weight of the things contained in the box can never exceed the box maximum capacity.</p>

            <p>The following example clarifies the box use:</p>

            <pre class="sh_java">
    public static void main(String[] args) {
        Box box = new Box(10);

        box.add( new Book("Fedor Dostojevski", "Crime and Punishment", 2) ) ;
        box.add( new Book("Robert Martin", "Clean Code", 1) );
        box.add( new Book("Kent Beck", "Test Driven Development", 0.7) );

        box.add( new CD("Pink Floyd", "Dark Side of the Moon", 1973) );
        box.add( new CD("Wigwam", "Nuclear Nightclub", 1975) );
        box.add( new CD("Rendezvous Park", "Closer to Being Here", 2012) );

        System.out.println( box );
    }
            </pre>

            <p>Printing:</p>

            <pre>
Box: 6 things, total weight 4.0 kg
            </pre>

            <p>Note: because the weights are represented as double, the rounding can cause small mistakes. You don't need to care about it when you do the exercise.</p>

            <h4 class="req">Box weight</h4>

            <p>If you created the object variable <code>double weght</code> in your box which records the weight of your things, replace it now with a method which calculates the weight:</p>

            <pre class="sh_java">
public class Box {
    //...

    public double weight() {
        double weight = 0;
        // it calculates the total weight of the things which had been stored
        return weight;
    }
}
            </pre>

            <p>When you need the box weight -- if you have to add a new thing, for instance -- you can simply call the method which calculates it.</p>

            <p>In fact, the method could work well even though it retured the value of an object variable. However, we train a situation where you don't need to maintain the object variable explicitly, but you can calculate it when you need it. With the following exercise, the information stored in a box object variable would not necessarily work properly, however. Why?</p>

            <h4 class="req">Boxes are Stored too!</h4>

            <p>Implementing the interface <code>ToBeStored</code> requires that the class has the method <code>double weight()</code>. In fact, we just added this method to Box. Boxes can be stored!</p>

            <p>Boxes are objects where we can store object which implement the interface <code>ToBeStored</code>. Boxes also implement this interface. This means that <b>you can also put boxes inside your boxes!</b></p>

            <p>Try this out: create a couple of boxes in your program, put things into the boxes and put smaller boxes into the bigger ones. Try also what happens when you put a box into itself. Why does it happen?</p>
          </div>
        </div>

        <h3>An Interface as Method Return Value</h3>

        <p>As well as any other variable type, an interface can also be used as method return value. Below you find <code>Factory</code>, which can be used to produce different objects that implement the interface <code>Item</code>. In the beginning, Factory produces books and disks at random.</p>

        <pre class="sh_java">
   public class Factory {
      public Factory(){
          // Attention: it is not necessary to write an empty constructor if there are no other constructors in the class.
      // In such cases, Java creates a default constructor, i.e a constructor without parameter
      }

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(4);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           }
       }
   }
        </pre>

        <p>It is possible to use our Factory without knowing precisely what kind of classes are present in it, as long as they all implement Item. Below you find the class <code>Packer</code> which can be used to get a boxful of items. The Packer knows the factory which produces its Items:</p>

        <pre class="sh_java">
   public class Packer {
       private Factory factory;

       public Packer(){
            factory = new Factory();
       }

       public Box giveABoxful() {
            Box box = new Box(100);

            for ( int i=0; i &lt; 10; i++ ) {
                Item newItem = factory.produceNew();
                box.add(newItem);
            }

            return box;
       }
   }
        </pre>

        <p>Because the packer doesn't know the classes which implement the Item interface, it is possble to add new classes which implement the interface without having to modify the packer. Below, we create a new class which implements our Item interface - <code>ChocolateBar</code>. Our Factory was modified to produce chocolate bars in addition to books and CDs. The class <code>Packer</code> works fine with the extended factory version, without having to change it.</p>

        <pre class="sh_java">
   public class ChocolateBar implements Item {
      // we don't need a constructor because Java is able to generate a default one!

      public double weight(){
         return 0.2;
      }
   }

   public class Factory {
      // we don't need a constructor because Java is able to generate a default one!

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(5);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else if ( num==3 ) {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           } else {
               return new ChocolateBar();
           }
       }
   }
        </pre>


        <p><em>Using interfaces while programming permits us to reduce the number of dependences among our classes. In our example, Packer is not dependent on the classes which implement Item interface, it is only dependent on the interface itself. This allows us to add classes wihout having to change the class Packer, as long as they implement our interface. We can even add classes that implement the interface to the methods which make use of our packer without compromising the process. In fact, less dependences make it easy to extend a program.</em></p>


        <!--
<p>We can imlement now the classes <code>PieceOfNews</code> and <code>NewsService</code>; the first reports a singular piece of news, and the second produces the news to be read. The code which makes use of our news service does not have to know the actual news implementation, and that is not even sensible. The only essential thing is that the program is able to read the news. In fact, the news service can submit its news through the <code>Readable</code> interface.</p>

<pre class="sh_java">
public class PieceOfNews implements Readable {
    private String text;

    public PieceOfNews(String text) {
        this.text = text;
    }

    public String read() {
        return this.text;
    }
}
</pre>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot Topics!");
    }
}
</pre>

        <p>The news service always submits a <code>Readable</code> interface object. At this point, people often wonder a simple question: "<code>Why shouldn't we simply use the class PieceOfNews?</code>". The answer is quite long but hopefully it will clear the idea behind this.</p>

        <p>Let us think about a situation where we have a <code>Publisher</code> which publishes news. The publisher has to read the news from the NewsService regularly, and print out the messages (the Publisher could send the message to different media, but let's stick to a basic example). Let us suppose that NewsService returns PieceOfNews objects.</p>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot News!");
    }
}
</pre>

        <p>Publisher's essential functionality is a loop, which calls the method <code>getLatestNews</code> with regular intermissions.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            PieceOfNews news = newsService.getLatestNews();
            System.out.println(news.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>So far, everything works well. We can now suppose our CEO notices that they need a new format for graphic news. Thus, we create a different class called <code>GraphicPieceOfNews</code>. GraphicPieceOfNews is readable so our NewsService programmer make it implement our Readable interface.</p>

<pre class="sh_java">
public class GraphicPieceOfNews implements Readable {
    private String imageAddress;
    private String text;

    public GraphicPieceOfNews(String text, String imageAddress) {
        this.text = text;
        this.imageAddress = imageAddress;
    }

    public String read() {
        return this.text + " (image address: " + this.imageAddress + ")";
    }
}
</pre>

        <p>Meanwhile, they also have to modify NewsService class, because it doesn't support the new news format: </p>

<pre class="sh_java">
public class NewsService {

    public GraphicPieceOfNews getLatestNews() {
        return new GraphicPieceOfNews("Latest Hot News!", "image address");
    }
}
</pre>

        <p>Now <em>we have to</em> modify our Publisher. In fact, it does not work any more because it returns an instance of the class <code>GraphicPieceOfNews</code>. How many classes we would have to modify if the news service used ten services, and what about one thousand? At this point <em>each</em> implementation which used our news service should change its own functionality.</p>

        <p>And what about if not all the pieces of news contained photos, and sometimes we wanted to return a <code>PieceOfNews</code> class instance? The method above, <code>getLatestNews</code>, may not be enough.</p>

        <p>Let's go back to our news format change, where the return type of the news service method <code>getLatestNews</code> is <code>Readable</code>.</p>


<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new PieceOfNews("The Latest Hot News!");
    }
}
</pre>

        <p>If the news service CEO wanted to get a new image format, we would not need to modify the <code>getLatestNews</code> method at all.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new GraphicPieceOfNews("The Latest Hot News!", "Photo's address");
    }
}
</pre>

        <p>Not even the Publisher would need any modification.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            Readable readable = newsService.GraphicPieceOfNews();
            System.out.println(readable.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>How many classes should we have modified if our news service offered ten services, and what about one thousand? Zero. And what about if our news service wanted to send sometimes normal news and sometimes graphic news? Easy! We only need to change our news service.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        Random random = new Random();

        if(random.nextDouble() > 0.5) {
            return new PieceOfNews("The Latest Hot News!");
        }

        return new GraphicPieceOfNews("The Latest Hot News!", "photo's address");
    }
}
</pre>

    <p>Even in this case we don't need to change the implementations which make use of our NewsService.</p>


    <p><em>Coding to interface allows for reducing the dependences. If all the services which make use of our news service were coded to the interface Readable, they would not be dependent on any particular class which implements the Readable interface. In the wxamples above, the internal implementation of the news service can be modified so that the modifications would not affect the objects which make use of the news service, in any way.</em></p>
-->

        <!-- TODO: tarkista onko sama kuin "Valmiit rajapinnat"-->
        <h3>Made-Up Interfaces</h3>

        <p>Java API offers a sensible number of made-up interfaces. Below, we get to know some of Java's most used interfaces: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> and <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>

        <h4>List</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> interface defines lists basic functionality. Because the class ArrayList implements the <code>List</code> interface, it can also be initialized through the <code>List</code> interface.</p>

        <pre class="sh_java">
List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add("A String object within an ArrayList object!");
        </pre>

        <p>As we notice from the <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List interface Java API</a>, there are a lot of classes which implement the interface <code>List</code>. A list construction which is familiar to hakers like us is the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>. A linked list can be used through the List interface in the same way as the objects created from ArrayList.</p>

        <pre class="sh_java">
List&lt;String&gt; strings = new LinkedList&lt;String&gt;();
strings.add("A string object within a LinkedList object!");
        </pre>

        <p>Both implementations of the <code>List</code> interface work in the same way, in the user point of view. In fact, the interface <em>abstracts</em> their internal functionality. ArrayList and linkedList internal construction is evidently different, anyway. ArrayList saves the objects into a table, and the search is quick with a specific index. Differently, LinkedList builds up a list where each item has a reference to the following item. When we search for an item in a linked list, we have to go through all the list items till we reach the index.</p>

        <p>When it comes to bigger lists, we can point out more than evident performance differences. LinkedList's strength is that adding new items is always fast. Differently, behind ArrayList there is a table which grows as it fills up. Increasing the size of the table means creating a new one and copying there the information of the old. However, searching against an index is extremely fast with an ArrayList, whereas we have to go thourgh all the list elements one by one before reaching the one we want, with a LinkedList. More information about data structures such as ArrayList and LinkedList internal implementation comes with the course <em>Data structures and algorithms</em>.</p>

        <p>In our programming course you will rather want to choose ArrayList, in fact. Programming to interface is worth of it, anyway: implement your program so that you'll use data structures via interfaces.</p>

        <h4>Map</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> Interface defines HashMap basic fuctionality. Because HashMaps implement the <code>Map</code> interface, it is possible to initialize them trough the <code>Map</code> interface.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "tsemppiä");
translations.put("hai", "kyllä");
        </pre>

        <p>You get HashMap keys thourgh the method <code>keySet</code>.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

for(String key: translations.keySet()) {
    System.out.println(key + ": " + translations.get(key));
}
        </pre>

        <pre>
gambatte: good luck
hai: yes
        </pre>

        <p>The <code>keySet</code> method returns a set made of keys which implement <code>Set</code> interface. The set which implement the <code>Set</code> interface can be parsed with a for-each loop. HashMap values are retrieved through the <code>values</code> method, which returns a set of values which implement the <code>Collection</code> interface. We should now focus on Set and Collection interfaces.</p>

        <h4>Set</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> interface defines the functionality of Java's sets. Java's sets always contain 0 or 1 element of a certain type. Among the others, <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code> is one of the classes which implement the Set interface. We can parse a key set through a for-each loop, in the following way</p>

        <pre class="sh_java">
Set&lt;String&gt; set = new HashSet&lt;String&gt;();
set.add("one");
set.add("one");
set.add("two");

for (String key: set) {
    System.out.println(key);
}
        </pre>

        <pre>
one
two
        </pre>

        <p>Notice that HashSet is not concerned on the order of its keys.</p>

        <h4>Collection</h4>

        <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> interface defines the functionality of collections. Among the others, Java's lists and sets are collections -- that is, List and Set interfaces implement the Collection interface. Collection interface provides methods to check object existence (the <code>contains</code> method) and to check the collection size (<code>size</code> method). We can parse any class which implements the Collection interface with a <code>for-each</code> loop. </p>

        <p>We now create a HashMap and parse first its keys, and then its values.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

Set&lt;String&gt; keys = translations.keySet();
Collection&lt;String&gt; keySet = keys;

System.out.println("Keys:");
for(String key: keySet) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
Collection&lt;String&gt; values = translations.values();
for(String value: values) {
    System.out.println(value);
}
        </pre>

        <pre>
Keys:
gambatte
hai

Values:
yes
good luck
        </pre>


        <p>The following example would have produced the same output, too.</p>

        <pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

System.out.println("Keys:");
for(String key: translations.keySet()) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
for(String value: translations.values()) {
    System.out.println(value);
}
        </pre>

        <p>In the following exercise we build an online shop, and we train to use classes through their interfaces.</p>

        <div class="tehtavat">
          <div class="tehtava">
            <h3>Online Shop</h3>

            <p>Next, we create some programming components which are useful to manage an online shop.</p>

            <h4>Storehouse</h4>

            <p>Create the class Storehouse with the following methods:</p>

            <ul><li><code>public void addProduct(String product, int price, int stock)</code>, adding to the storehouse a product whose price and number of stocks are the parameter values</li>
              <li><code>public int price(String product)</code> returns the price of the parameter product; if the product is not available in the storehouse, the method returns -99</li>
            </ul><p>Inside the storehouse, the prices (and soon also the stocks) of the products have to be stored into a <code>Map&lt;String, Integer&gt;</code> variable! The type of the object so created can be <code>HashMap</code>, but you should use the interface <code>Map</code> for the variable type (see 40.4.2)</p>

            <p>The next example clarifies storehouse use:</p>

            <pre class="sh_java">
        Storehouse store = new Storehouse();
        store.addProduct("milk", 3, 10);
        store.addProduct("coffee", 5, 7);

        System.out.println("prices:");
        System.out.println("milk:  " + store.price("milk"));
        System.out.println("coffee:  " + store.price("coffee"));
        System.out.println("sugar: " + store.price("sugar"));
            </pre>

            <p>Prints:</p>

            <pre>
prices:
milk:  3
coffee:  5
sugar: -99
            </pre>

            <h4>Product Stock</h4>

            <p>Store product stocks in a similar <code>Map&lt;String, Integer&gt;</code> variable as the one you used for their prices. Fill the Storehouse with the following methods:</p>

            <ul><li><code>public int stock(String product)</code> returns the stock of the parameter product.</li>
              <li><code>public boolean take(String product)</code> decreases the stock of the parameter product by one, and it returns <em>true</em> if the object was available in the storehouse. If the product was not in the storehouse, the method returns <em>false</em>, the product stock cannot go below zero.</li>
            </ul><p>An example of how to use the storehouse now:</p>

            <pre class="sh_java">
        Storehouse store = new Storehouse();
        store.addProduct("coffee", 5, 1);

        System.out.println("stocks:");
        System.out.println("coffee:  " + store.stock("coffee"));
        System.out.println("sugar: " + store.stock("sugar"));

        System.out.println("we take a coffee " + store.take("coffee"));
        System.out.println("we take a coffee " + store.take("coffee"));
        System.out.println("we take sugar " + store.take("sugar"));

        System.out.println("stocks:");
        System.out.println("coffee:  " + store.stock("coffee"));
        System.out.println("sugar: " + store.stock("sugar"));
            </pre>

            <p>Prints:</p>

            <pre>
stocks:
coffee:  1
sugar: 0
we take coffee true
we take coffee false
we take sugar false
stocks:
coffee:  0
sugar: 0
            </pre>

            <h4>Listing the Products</h4>

            <p>Let's add another method to our storehouse:</p>

            <ul><li><code>public Set&lt;String&gt; products()</code> returns a name <em>set</em> of the products contained in the storehouse</li>
            </ul><p>The method can be implemented easily. Using the Map's method <code>keySet</code>, you can get the storehouse products by asking for their prices or stocks.</p>

            <p>An example of how to use the storehose now:</p>

            <pre class="sh_java">
        Storehouse store = new Storehouse();
        store.addProduct("milk", 3, 10);
        store.addProduct("coffee", 5, 6);
        store.addProduct("buttermilk", 2, 20);
        store.addProduct("jogurt", 2, 20);

        System.out.println("products:");
        for (String product : store.products()) {
            System.out.println(product);
        }
            </pre>

            <p>Prints:</p>

            <pre>
products:
buttermilk
jogurt
coffee
milk
            </pre>

            <h4>Purchase</h4>

            <p>We add <em>purchases</em> to our shopping basket. With purchase we mean a specific number of a specific product. For instance, we can put into our shopping basket either a purchase corresponding to one bread, or a purchase corresponding to 24 coffees.</p>

            <p>Create the class <code>Purchase</code> with the following functionality:</p>

            <ul><li>a constructor <code>public Purchase(String product, int amount, int unitPrice)</code>, which creates a purchase corresponding the parameter product. The product unit amount of purchase is clarified by the parameter <em>amount</em>, and the third parameter is the <em>unit price</em></li>
              <li><code>public int price()</code>, which returns the purchase price. This is obtained by raising the unit amount by the unit price</li>
              <li><code>public void increaseAmount()</code> increases by one the purchase unit amount</li>
              <li><code>public String toString()</code> returns the purchase in a string form like the following</li>
            </ul><p>An example of how to use a purchase</p>

            <pre class="sh_java">
        Purchase purchase = new Purchase("milk", 4, 2);
        System.out.println( "the total price of a purchase containing four milks is " + purchase.price() );
        System.out.println( purchase );
        purchase.increaseAmount();
        System.out.println( purchase );
            </pre>

            <p>Prints:</p>

            <pre>
the total price of a purchase containing four milks is 8
milk: 4
milk: 5
            </pre>

            <p>Note: <em>toString</em> follows the pattern <em>product: amount</em>, but the price is not reported!</p>

            <h4>Shopping Basket</h4>

            <p>Finally, we can implement our shopping basket class!</p>

            <p>The shopping basket stores its products as <em>Purchase objects</em>. The shopping basket has to have an object variable whose type is either <code>Map&lt;String, Purchase&gt;</code> or <code>List&lt;Purchase&gt;</code>. Do not create any other object variable for your shopping basket in addition to the Map or List needed to store purchases.</p>

            <p>Attention: if you store a Purchase object in a Map helping variable, it will be useful to use the Map method values() in this and in the following exercise; with it, it's easy to go through all the stored Purchase objects.</p>

            <p>Let's create a constructor without parameter for our shopping basket, as well as the following methods:</p>

            <ul><li><code>public void add(String product, int price)</code> adds a purchase to the shopping basket; the purchase is defined by the parameter product, and its price is the second parameter.</li>
              <li><code>public int price()</code> returns the shopping basket total price</li>
            </ul><p>Example code of using basket</p>

            <pre class="sh_java">
        ShoppingBasket basket = new ShoppingBasket();
        basket.add("milk", 3);
        basket.add("buttermilk", 2);
        basket.add("cheese", 5);
        System.out.println("basket price: " + basket.price());
        basket.add("computer", 899);
        System.out.println("basket price: " + basket.price());
            </pre>

            <p>Prints:</p>

            <pre>
basket price: 10
basket price: 909
            </pre>

            <h4>Printing out the Shopping Basket</h4>

            <p>Let's create the method <code>public void print()</code> for our shopping basket. This prints out the <em>Purchase</em> objects which are contained by the basket. The printing order is not important. The output of the shopping basket in the previous example would be:</p>

            <pre>
butter: 1
cheese: 1
computer: 1
milk: 1
            </pre>

            <p>Note that the number stands for the unit amount of the products, not for their price!</p>

            <h4>Only One Purchase Object for One Product</h4>

            <p>Let's update our Shopping Basket; if the basket already contains the product which we add, we don't create a new Purchase object, but we update the Purchase object corresponding to the existing product by calling its method <em>increaseAmount()</em>.</p>

            <p>Example:</p>

            <pre class="sh_java">
        ShoppingBasket basket = new ShoppingBasket();
        basket.add("milk", 3);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");

        basket.add("buttermilk", 2);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");

        basket.add("milk", 3);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");

        basket.add("milk", 3);
        basket.print();
        System.out.println("basket price: " + basket.price() +"\n");
            </pre>

            <p>Prints:</p>

            <pre>
milk: 1
basket price: 3

buttermilk: 1
milk: 1
basket price: 5

buttermilk: 1
milk: 2
basket price: 8

buttermilk: 1
milk: 3
basket price: 11
            </pre>

            <p>This means that first, we add milk and buttermilk, creating new Purchase objects for them. When we add more milk to the basket, we don't create a new purchase object for the milk, but we update the unit amount of the purchase object representing the milk we already have in the basket.</p>

            <h4>Shop</h4>

            <p>Now, all the parts of our online shop are ready. Our online shop has a storage house, which contains all products. We have got a shopping basket to manage all our customers. Whenever a customer chooses a purchase, we add it to the shopping basket if the product is available in our storage house. Meanwhile, the storage stocks are reduced by one.</p>

            <p>Below, you find a ready-made code body for your online shop. Create the class <code>Shop</code> to your project, and copy the code below into it.</p>

            <pre class="sh_java">
import java.util.Scanner;

public class Shop {

    private Storehouse store;
    private Scanner reader;

    public Shop(Storehouse store, Scanner reader) {
        this.store = store;
        this.reader = reader;
    }

    // the method to deal with a customer in the shop
    public void manage(String customer) {
        ShoppingBasket basket = new ShoppingBasket();
        System.out.println("Welcome to our shop " + customer);
        System.out.println("below is our sale offer:");

        for (String product : store.products()) {
            System.out.println( product );
        }

        while (true) {
            System.out.print("what do you want to buy (press enter to pay):");
            String product = reader.nextLine();
            if (product.isEmpty()) {
                break;
            }

            // here, you write the code to add a product to the shopping basket, if the storehouse is not empty
            // and decreases the storehouse stocks
            // do not touch the rest of the code!

        }

        System.out.println("your purchases are:");
        basket.print();
        System.out.println("basket price: " + basket.price());
    }
}
            </pre>

            <p>The following main program fills the shop storehouse and manages the customer Pekka:</p>

            <pre class="sh_java">
    Storehouse store = new Storehouse();
    store.addProduct("coffee", 5, 10);
    store.addProduct("milk", 3, 20);
    store.addProduct("milkbutter", 2, 55);
    store.addProduct("bread", 7, 8);

    Shop shop = new Shop(store, new Scanner(System.in));
    shop.manage("Pekka");
            </pre>

            <p>The shop is almost ready. There are comments in the method <code>public void manage(String customer)</code>, showing the part that you should implement. In that point, implement the code to check whether the object the customer wants is available in the storehouse. If so, reduce the storehouse stocks by one unit, and add the product to the shopping basket.</p>

            <p><em>Now you have done something! verkkokauppa.com!</em></p>
          </div>
        </div>

        <h2>Generics</h2>

        <p>We speak about <em>Generics</em> in connection to the way classes can conserve objects of genric type. Generics is based on the generic type parameter which is used when we define a class, and which helps us to define the types that have to be chosen when an <em>object is created</em>. A class generics can be defined by setting up the number of type parameters we want. This number is written after the class name and between the greater-than and less-than signs. We now implement our own generic class <code>Slot</code> which be assigned whatever object.</p>

        <pre class="sh_java">
public class Slot&lt;T&gt; {
    private T key;

    public void setValue(T key) {
        this.key = key;
    }

    public T getValue() {
        return key;
    }
}
        </pre>

        <p>The definition <code>public class Slot&lt;T&gt;</code> tells us that we have to give a type parameter to the constructor of the class <code>Slot</code>. After the constructor call the object variables have to be the same type as what established with the call. We now create a slot which memorizes strings.</p>

        <pre class="sh_java">
    Slot&lt;String&gt; string = new Slot&lt;String&gt;();
    string.setValue(":)");

    System.out.println(string.getValue());
        </pre>

        <pre>
:)
        </pre>

        <p>If we change the type parameter we can create different kinds of <code>Slot</code> ojects, whose purpose is to memorize objects. For instance, we can memorize an integer in the following way:</p>

        <pre class="sh_java">
    Slot&lt;Integer&gt; num = new Slot&lt;Integer&gt;();
    num.setValue(5);

    System.out.println(slot.getValue());
        </pre>


        <pre>
5
        </pre>

        <p>An important part of Java data structures are programmed to be generic. For instance, ArrayList receives one parameter, HashMap two.</p>

        <pre class="sh_java">
    List&lt;String&gt; string = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; keyCouples = new HashMap&lt;String, String&gt;();
        </pre>

        <p>In the future, when you see the type <code>ArrayList&lt;String&gt;</code>, for instance, you know that its internal structure makes use of a generic type parameter.</p>

        <h3>The Interface which Makes Use of Generics: Comparable</h3>

        <p>In addition to normal interfaces, Java has interfaces which make use of generics. The internal value types of generic interfaces are defined in the same way as for generic classes. Let us have a look at Java made-up <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code> interface. The <code>Comparable</code> interface defines the <code>compareTo</code> method, which returns the place of <code>this</code> object, in relation to the parameter object (a negative number, 0, or a positive number). If <code>this</code> object is placed before the parameter object in the comparison order, the method returns a negative value, whereas it returns a positive value if it is placed after the parameter object. If the objects are placed at the same place in the comparison order, the method returns 0. With comparison order we mean the object order of magnitude defined by the programmer, i.e. the object order, when they are sorted with the sort method.</p>

        <p>One of the advantages of the <code>Comparable</code> interface is that it allows us to sort a list of Comparable type keys by using the standard library method <code>Collections.sort</code>, for instance. <code>Collections.sort</code> uses the <code>compareTo</code> method of a key list to define in which order these keys should be. We call <em>Natural Ordering</em> this ordering technique which makes use of the <code>compareTo</code> method.

        </p><p>We create the class <code>ClubMember</code>, which depicts the young people and children who belong to the club. The members have to eat in order of height, so the club members will implement the interface <code>Comparable</code>. The interface <code>Comparable</code> also takes as type parameter the class which it is compared to. As type parameter, we use the <code>ClubMember</code> class.</p>

        <pre class="sh_java">
public class ClubMember implements Comparable&lt;ClubMember&gt; {
    private String name;
    private int height;

    public ClubMember(String name, int height) {
        this.name = name;
        this.height = height;
    }

    public String getName() {
        return this.name;
    }

    public int getHeight() {
        return this.height;
    }

    @Override
    public String toString() {
        return this.getName() + " (" + this.getHeight() + ")";
    }

    @Override
    public int compareTo(ClubMember clubMember) {
        if(this.height == clubMember.getHeight()) {
            return 0;
        } else if (this.height &gt; clubMember.getHeight()) {
            return 1;
        } else {
            return -1;
        }
    }
}
        </pre>

        <p>The interface requires the method <code>compareTo</code>, which returns an integer that tells us the comparison order. Our <code>compareTo()</code> method has to return a negative number if <code>this</code> object is smaller than its parameter object, or zero, if the two members are equally tall. Therefore, we can implement the above <code>compareTo</code> method, in the following way:</p>

        <pre class="sh_java">
    @Override
    public int compareTo(ClubMember clubMember) {
        return this.height - clubMember.getHeight();
    }
        </pre>

        <p>Sorting club members is easy, now.</p>

        <pre class="sh_java">
    List&lt;ClubMember&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    System.out.println(clubMembers);
    Collections.sort(clubMembers);
    System.out.println(clubMembers);
        </pre>

        <pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
        </pre>

        <p>If we want to sort the members in descending order, we only have to switch the variable order in our <code>compareTo</code> method.</p>


        <div class="tehtavat">
          <div class="tehtava">

            <h3>Rich First, Poor Last</h3>

            <p>You find the pre-made class Person. People have got name and salary information. Make Person implement the <code>Comparable</code> interface, so that the <code>compareTo</code> method would sort the people according to their salary -- rich first, poor last.</p>

          </div>
          <div class="tehtava">

            <h3>Students Sorted by Name</h3>

            <p>You find the pre-made class Student. Students have got a name. Make Student implement the <code>COmparable</code> interface, so that the <code>compareTo</code> method would sort the students in alphabetic order.</p>

            <p><b>Tip:</b> student names are Strings, the class String is <code>Comparable</code> itself. You can use the String's <code>compareTo</code> method when you implement your Student class. <code>String.compareTo</code> gives a different value to characters according to their case; because of this, String has also got the method <code>compareToIgnoreCase</code> which, in fact, ignores the case while comparing. You can use either of them, when you sort your students.</p>

          </div>
          <div class="tehtava">

            <h3>Sorting Cards</h3>

            <p>Together with the exercise layout, you find a class whose objects represent playing cards. Cards have got a value and a suit. Card values are <em>2, 3, ..., 10, J, Q, K </em> and <em>A</em>, and the suits are <em>Spades, Hearts, Diamonds</em> and <em>Clubs</em>. Value and suit are however shown as integers in the objects. Cards have also got a toString method, which is used to print the card value and suit in a "friendly way". </p>

            <p>Four constants -- that is <code>public static final</code> variables -- are defined in the class, so that the user didn't need to handle card's suits as numbers:</p>

            <pre class="sh_java">
public class Card {
    public static final int SPADES  = 0;
    public static final int DIAMONDS  = 1;
    public static final int HEARTS = 2;
    public static final int CLUBS   = 3;

    // ...
}
            </pre>

            <p>Now, instead of writing the number 1, we can use the constant <code>Card.DIAMONDS</code> in our program. In the following example, we create three cards and print them:</p>

            <pre class="sh_java">
  Card first = new Card(2, Card.DIAMONDS);
  Card second = new Card(14, Card.CLUBS);
  Card third = new Card(12, Card.HEARTS);

  System.out.println(first);
  System.out.println(second);
  System.out.println(third);
            </pre>

            <p>Prints:</p>

            <pre>
2 of Diamonds
A of Clubs
Q of Hearts
            </pre>

            <p><b>Note:</b> using constants as shown above is not the best way deal with things. Later on in the course we learn a better way to show suits!</p>

            <h4>Comparable Cards</h4>

            <p>Make your Cards class Comparable. Implement the <code>compareTo</code> method so that cards would be sorted in ascending order according to their value. If the value of two classes have got the same values, we compare them against their suit in ascending order: <em>spades first, diamonds second, hearts third, and clubs last</em>.</p>

            <p>The smallest card would then be the two spades and the greatest would be the clubs ace.</p>

            <h4>Hand</h4>

            <p>Next, let's create the class <code>Hand</code> which represents the player hand set of cards. Create the following method to the hand:</p>

            <ul><li><code>public void add(Card card)</code> adds a card to the hand</li>
              <li><code>public void print()</code> prints the cards in the hand following the below example pattern</li>
            </ul><pre class="sh_java">
  Hand hand = new Hand();

  hand.add( new Card(2, Card.SPADES) );
  hand.add( new Card(14, Card.CLUBS) );
  hand.add( new Card(12, Card.HEARTS) );
  hand.add( new Card(2, Card.CLUBS) );

  hand.print();
            </pre>

            <p>Prints:</p>

            <pre>
2 of Spades
A of Clubs
Q of Hearts
2 of Clubs
            </pre>

            <p>Store the hand cards into an ArrayList.</p>

            <h4>Sorting the Hand</h4>

            <p>Create the method <code>public void sort()</code> for your hand, which sorts the cards in the hand. After being sorted, the cards are printed in order:</p>

            <pre class="sh_java">
  Hand hand = new Hand();

  hand.add( new Card(2, Card.SPADES) );
  hand.add( new Card(14, Card.CLUBS) );
  hand.add( new Card(12, Card.HEARTS) );
  hand.add( new Card(2, Card.CLUBS) );

  hand.sort();

  hand.print();
            </pre>

            <p>Prints:</p>

            <pre>
2 of Spades
2 of Clubs
Q of Hearts
A of Clubs
            </pre>

            <h4>Comparing Hands</h4>

            <p>In one card game, the most valuable hand, where the sum of the cards value is the biggest. Modify the class <code>Hand</code> so that it could be compared according to this criterion: make it implement the interface <code>Comparable&lt;Hand&gt;</code>.</p>

            <p>Below, you find an example of a program where we compare hands:</p>

            <pre class="sh_java">
  Hand hand1 = new Hand();

  hand1.add( new Card(2, Card.SPADES) );
  hand1.add( new Card(14, Card.CLUBS) );
  hand1.add( new Card(12, Card.HEARTS) );
  hand1.add( new Card(2, Card.CLUBS) );

  Hand hand2 = new Hand();

  hand2.add( new Card(11, Card.DIAMONDS) );
  hand2.add( new Card(11, Card.CLUBS) );
  hand2.add( new Card(11, Card.HEARTS) );

  int comparison = hand1.compareTo(hand2);

  if ( comparison &lt; 0 ) {
    System.out.println("the most valuable hand contains the cards");
    hand2.print();
  } else if ( comparison &gt; 0 ){
    System.out.println("the most valuable hand contains the cards");
    hand1.print();
  } else {
    System.out.println("the hands are equally valuable");
  }
            </pre>

            <p>Prints:</p>

            <pre>
the most valuable hand contains the cards
J of Diamonds
J of Clubs
J of Hearts
            </pre>

            <h4>Sorting the Cards against Different Criteria</h4>

            <p>What about if we wanted to sort cards in a slightly different way, sometimes; for instance, what about if we wanted to have all same-suit cards in a raw? The class can have only one compareTo method, which means that we have to find out other ways to sort cards against different orders.</p>

            <p>If you want to sort your cards in optional orders, you can make use of different classes which execute the comparison. These classes have to implement the interface <code>Comparator&lt;Card&gt;</code>. The object which determines the sorting order compares two cards it receives as parameter. There is only one method, a compare(Card card1, Card card2) method which has to return a negative value if card1 is before card2, a positive value if card2 is before card1, and 0 otherwise.</p>

            <p>The idea is creating a specific comparison class for each sorting order; for instance, a class which places same suit cards together in a row:</p>

            <pre class="sh_java">
import java.util.Comparator;

public class SortAgainstSuit implements Comparator&lt;Card&gt; {
    public int compare(Card card1, Card card2) {
        return card1.getSuit()-card2.getSuit();
    }
}
            </pre>

            <p>Sorting against suit works in the same way as the card method <code>compareTo</code> thought for suits, that is <em>spades first, diamonds second, hearts third, clubs last.</em></p>

          <p>Sorting is still possible through the Collections' sort method. The method now receives as second parameter an object of the class that determines the sorting order:</p>

          <pre class="sh_java">
  ArrayList&lt;Card&gt; cards = new ArrayList&lt;Card&gt;();

  cards.add( new Card(3, Card.CLUBS) );
  cards.add( new Card(2, Card.DIAMONDS) );
  cards.add( new Card(14, Card.CLUBS) );
  cards.add( new Card(12, Card.HEARTS) );
  cards.add( new Card(2, Card.CLUBS) );

  SortAgainstSuit suitSorter = new SortAgainstSuit();
  Collections.sort(cards, suitSorter );

  for (Card c : cards) {
    System.out.println( c );
  }
          </pre>

          <p>Prints:</p>

          <pre>
2 of Diamonds
Q of Hearts
3 of Clubs
A of Clubs
2 of Clubs
          </pre>

          <p>The sorting object can also be created directly together with the sort call:</p>

          <pre class="sh_java">
  Collections.sort(cards, new SortAgainstSuit() );
          </pre>
          <p>

          </p><p>Further information about comparator classes in <a href="http://leepoint.net/notes-java/data/collections/comparators.html">here.</a></p>

          <p>Create now the class <code>SortAgainstSuitAndValue</code> which implements the Comparator interface and sorts cards as it is done in the example above, plus same suit cards are also sorted according to their value.
          </p>

          <h4>Sort Against Suit</h4>

          <p>Add the method <code>public void sortAgainstSuit()</code> to the class <code>Hand</code>; when the method is called the hand's cards are sorted according to the comparator <code>SortAgainstSuitAndValue</code>. After sorting them, the cards are printed in order:</p>

          <pre class="sh_java">
  Hand hand = new Hand();

  hand.add( new Card(12, Card.HEARTS) );
  hand.add( new Card(4, Card.CLUBS) );
  hand.add( new Card(2, Card.DIAMONDS) );
  hand.add( new Card(14, Card.CLUBS) );
  hand.add( new Card(7, Card.HEARTS) );
  hand.add( new Card(2, Card.CLUBS) );

  hand.sortAgainstSuit();

  hand.print();
          </pre>

          <p>Prints:</p>

          <pre>
2 of Diamonds
7 of Hearts
Q of Hearts
2 of Clubs
4 of Clubs
A of Clubs
          </pre>

        </div>
      </div>

      <h2>Collections</h2>

      <p>The class library <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code> is Java's general-purpose library for collection classes. As we can see, <code>Collections</code> provides methods to sort objects either through the interface <code>Comparable</code> or <code>Comparator</code>. In addition to sorting, we can use this class library to retrieve the minimum and maximum values (through the methods <code>min</code> and <code>max</code>, respectively), retrieve a specific value (<code>binarySearch</code> method), or reverse the list (<code>reverse</code> method).</p>

      <h3>Search</h3>

      <p>The Collections class library provides a pre-made binary search functionality. The method <code>binarySearch()</code> returns the index of our searched key, if this is found. If the key is not found, the search algorithm returns a negative value. The method <code>binarySearch()</code> makes use of the Comparable interface to retieve objects. If the object's <code>compareTo()</code> method returns the value 0, i.e. if it is the same object, the key is considered found.</p>

      <p>Our ClubMember class compares people's heights in its <code>compareTo()</code> method, i.e. we look for club members whose height is the same while we parse our list.</p>

      <pre class="sh_java">
    List&lt;ClubMember&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    Collections.sort(clubMembers);

    ClubMember wanted = new ClubMember("Name", 180);
    int index = Collections.binarySearch(clubMembers, wanted);
    if (index &gt;= 0) {
        System.out.println("A person who is 180 centimeters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }

    wanted = new ClubMember("Name", 187);
    index = Collections.binarySearch(clubMembers, wanted);
    if (index &gt;= 0) {
        System.out.println("A person who is 187 centimeters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }
      </pre>

      <p>The print output is the following:</p>

      <pre>
A person who is 187 centimeters tall was found at index 2
name: matti
      </pre>

      <p>Notice that we also called the method <code>Collections.sort()</code>, in our example. This is because binary search cannot be done if our table or list are not already sorted up.</p>







      <div class="tehtavat">

        <div class="tehtava">

          <h3>Ski Jumping</h3>

          <p>Once again, you can train to build the program structure yourself; the appearance of the user interface and its functionality are pre-defined.</p>

          <p><b>Note: you can create only one Scanner object lest the tests fail. Also, no not use static variables: the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</b></p>

          <p>Ski jumping is a beloved sport for Finns; they attempt to land as far as possible down the hill below, in the most stylish way. In this exercise, you create a simulator for a ski jumping tournament.</p>

          <p>First, the simulator asks the user for the jumper names. If the user inputs an empty string (i.e. presses enter), we move to the jumping phase. In the jumping phase, the jumpers jump one by one in reverse order according to their points. The jumper with the less points always jumps first, then the ones with more points, till the person with the most points.</p>

          <p>The total points of a jumper are calculated by adding up the points from their jumps. Jump points are decided in relation to the jump length (use a random integer between 60-120) and judge decision. Five judges vote for each jump (a vote is a random number between 10-20). The judge decision takes into consideration only three judge votes: the smallest and the greatest votes are not taken into account. For instance, if Mikael jumps 61 meters and the judge votes are 11, 12, 13, 14, and 15, the total points for the jump are 100.</p>

          <p>There are as many rounds as the user wants. When the user wants to quit, we print the tournament results. The tournament results include the jumpers, the jumper total points, and the lengths of the jumps. The final results are sorted against the jumper total points, and the jumper who received the most points is the first.</p>

          <p>Among the other things, you will need the method <code>Collections.sort</code> and <code>Collections.reverse</code>. First, you should start to wonder what kind of classes and objects there could be in your program. Also, it would be good to arrive to a situation where your user interface is the only class with printing statements.</p>

          <pre>
Kumpula ski jumping week

Write the names of the participants one at a time; an empty string brings you to the jumping phase.
  Participant name: <font color="red">Mikael</font>
  Participant name: <font color="red">Mika</font>
  Participant name:

The tournament begins!

Write "jump" to jump; otherwise you quit: <font color="red">jump</font>

Round 1

Jumping order:
  1. Mikael (0 points)
  2. Mika (0 points)

Results of round 1
  Mikael
    length: 95
    judge votes: [15, 11, 10, 14, 14]
  Mika
    length: 112
    judge votes: [14, 12, 18, 18, 17]

Write "jump" to jump; otherwise you quit: <font color="red">jump</font>

Round 2

Jumping order:
  1. Mikael (134 points)
  2. Mika (161 points)

Results of round 2
  Mikael
    length: 96
    judge votes: [20, 19, 15, 13, 18]
  Mika
    length: 61
    judge votes: [12, 11, 15, 17, 11]

Write "jump" to jump; otherwise you quit: <font color="red">jump</font>

Round 3

Jumping order:
  1. Mika (260 points)
  2. Mikael (282 points)

Results of round 3
  Mika
    length: 88
    judge votes: [11, 19, 13, 10, 15]
  Mikael
    length: 63
    judge votes: [12, 19, 19, 12, 12]

Write "jump" to jump; otherwise you quit: <font color="red">quit</font>

Thanks!

Tournament results:
Position    Name
1           Mikael (388 points)
            jump lengths: 95 m, 96 m, 63 m
2           Mika (387 points)
            jump lengths: 112 m, 61 m, 88 m
          </pre>



          <p><strong>Note1:</strong> it is essential that the <em>user interface</em> works exactly as displayed above; for instance, the number of spaces at the beginning of the lines must be right. <strong>The space at the beginning of the lines must be made of spaces</strong>, the tests do not work if you use tabulatation. Also, it is good that you copy the text which has to be printed by your program and you paste it into your code; you can copy it either from the exercise layout or from the test error messages. <em>The exercise is worth of four separate exercise points.</em></p>

        <p><strong>The program has to start when we execute the main method in the example layout. Also, remember again that you can create only one Scanner object in your exercise.</strong></p>

      </div>
    </div>
    <!--
    <p>A screencast where we create a bigger application using what we have learnt in the first two weeks:</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=LFxtwce8chM" height="300" target="_blank"><img src="img/youtube.jpg"/></a>


    <p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/LFxtwce8chM"></iframe></p>
-->


  </div>    </div>


      </div><!-- /inner -->

  </div><!-- /node-312 -->
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
  </div>
</div>
</div>
</div>
                                                                  </div><!-- /content-content -->
                                                              </div><!-- /content-inner-inner -->
                            </div><!-- /content-inner -->
                          </div><!-- /content-region-inner -->
                        </div><!-- /content-region -->

                        <div id="content-bottom" class="content-bottom row nested ">
<div id="content-bottom-inner" class="content-bottom-inner inner clearfix">

<div id="block-block-1" class="block block-block odd first last grid16-16">
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
      	<div class="inner-wrapper">
      <div class="inner-inner">
                <div class="content clearfix">
          <div id="header-top-block">
<p class="rtecenter">
Help: <a href="https://riot.im/app/#/room/#mooc.fi:matrix.org">IRCnet/Matrix #mooc.fi </a>&nbsp;&nbsp; |  News: <a href="http://twitter.com/moocfi"><img src="/2013-oo-programming/resources/Twitter_Logo_Blue.png" height="50" style="vertical-align: middle;"></a><a href="http://www.facebook.com/Moocfi"><img src="/2013-oo-programming/resources/FB-f-Logo__blue_100.png" height="30" style="vertical-align: middle;"></a></p>
<p class="rtecenter">
<a href="http://www.cs.helsinki.fi">
<img alt="Helsingin yliopiston tietojenk&auml;sittelytieteen laitos" src="/2013-oo-programming/sites/mooc.cs.helsinki.fi/files/CS-logo-MOOC.jpg" width="400" style=" vertical-align: middle;" />&nbsp; </a></p>
	</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47575342-3', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');

</script>        </div>
      </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --></div><!-- /content-bottom-inner -->
</div><!-- /content-bottom -->
                      </div><!-- /content-group-inner -->
                    </div><!-- /content-group -->

                                      </div><!-- /main-content-inner -->
                </div><!-- /main-content -->

                              </div><!-- /main-group-inner -->
            </div><!-- /main-group -->
          </div><!-- /main-inner -->
        </div><!-- /main -->
      </div><!-- /main-wrapper -->

      <!-- postscript-bottom row: width = grid_width -->

      <!-- footer row: width = grid_width -->

      <!-- footer-message row: width = grid_width -->
      <div id="footer-message-wrapper" class="footer-message-wrapper full-width">
        <div id="footer-message" class="footer-message row grid16-16">
          <div id="footer-message-inner" class="footer-message-inner inner clearfix">
                              <div id="footer-message-text" class="footer-message-text block">
<div id="footer-message-text-inner" class="footer-message-text-inner inner clearfix">
<br />
</div><!-- /footer-message-text-inner -->
</div><!-- /footer-message-text -->

          </div><!-- /footer-message-inner -->
        </div><!-- /footer-message -->
      </div><!-- /footer-message-wrapper -->

    </div><!-- /page-inner -->
  </div><!-- /page -->
  </body>
</html>
