<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>MOOC | MOOC - Massive online open course</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/styles.css" />

  <link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/mooc.cs.helsinki.fi/files/ctools/css/5c1587b6907a85bc361bd4b70014b0e3.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/node/node.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/system/defaults.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/system/system.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/system/system-menus.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/modules/user/user.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/cck/theme/content-module.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/ckeditor/ckeditor.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/ctools/css/ctools.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/date/date.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/pan/css/panels.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/views/css/views.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/mooc.cs.helsinki.fi/files/ctools/css/aeb58e3ce47f9171327ad9fd87a26c8e.css" />
<link type="text/css" rel="stylesheet" media="all" href="/2013-oo-programming/sites/all/modules/pan/plugins/layouts/flexible/flexible.css" />
<script type="text/javascript" src="/2013-oo-programming/misc/jquery.js"></script>
<script type="text/javascript" src="/2013-oo-programming/misc/drupal.js"></script>
<script type="text/javascript" src="/2013-oo-programming/sites/all/modules/pan/js/panels.js"></script>
<script type="text/javascript">
<!--//--><![CDATA[//><!--
jQuery.extend(Drupal.settings, { "basePath": "/" });
//--><!]]>
</script>

<head>

<body id="pid-programming-part2-material-week-7" class="not-front not-logged-in page-node node-type-weekly-tasks no-sidebars full-node panels layout-main sidebars-both-first font-family-lucida font-size-13 grid-type-fluid grid-width-16 fluid-100">
  <div id="page" class="page">
    <div id="page-inner" class="page-inner">

      <!-- header-top row: width = grid_width -->

      <!-- header-group row: width = grid_width -->
      <div id="header-group-wrapper" class="header-group-wrapper full-width">
        <div id="header-group" class="header-group row grid16-16">
          <div id="header-group-inner" class="header-group-inner inner clearfix">
                                    <div id="primary-menu" class="primary-menu block">
<div id="primary-menu-inner" class="primary-menu-inner inner clearfix">
    <div class="navigation-wrapper"> <div class="navigation-links left">
        <a href="http://mooc.fi/english.html" title="Courses">Courses</a>
        <a class="not-active">Week 7</a>
        <a href="../week-8">Week 8</a>
        <a href="../week-9">Week 9</a>
        <a href="../week-10">Week 10</a>
        <a href="../week-11">Week 11</a>
        <a href="../week-12">Week 12</a>
      </div>
<div class="navigation-links right">                     <a href="https://riot.im/app/#/room/#mooc.fi:matrix.org">Chat</a>                 </div>                 </div> </div><!-- /primary-menu-inner -->
</div><!-- /primary-menu -->
          </div><!-- /header-group-inner -->
        </div><!-- /header-group -->
      </div><!-- /header-group-wrapper -->

      <!-- preface-top row: width = grid_width -->

<!--            <div id="preface-top-wrapper" class="preface-top-wrapper full-width">
        <div id="preface-top" class="preface-top row grid16-16">
          <div id="preface-top-inner" class="preface-top-inner inner clearfix">
-->
          </div><!-- /preface-top-inner -->
        </div><!-- /preface-top -->
      </div><!-- /preface-top-wrapper -->

    <!-- main row: width = grid_width -->
    <div id="main-wrapper" class="main-wrapper full-width">
      <div id="main" class="main row grid16-16">
        <div id="main-inner" class="main-inner inner clearfix">

          <!-- main group: width = grid_width - sidebar_first_width -->
          <div id="main-group" class="main-group row nested grid16-16">
            <div id="main-group-inner" class="main-group-inner inner clearfix">

              <div id="main-content" class="main-content row nested">
                <div id="main-content-inner" class="main-content-inner inner clearfix">
                  <!-- content group: width = grid_width - (sidebar_first_width + sidebar_last_width) -->
                    <div id="content-group" class="content-group row nested " style="width:100%">
                      <div id="content-group-inner" class="content-group-inner inner clearfix">


                        <div id="content-region" class="content-region row nested">
                          <div id="content-region-inner" class="content-region-inner inner clearfix">
                            <a name="main-content-area" id="main-content-area"></a>
                                                        <div id="content-inner" class="content-inner block">
                              <div id="content-inner-inner" class="content-inner-inner inner clearfix">
                                                                                                <div id="content-content" class="content-content">
                                  <div class="panel-flexible panels-flexible-13 clear-block" >
<div class="panel-flexible-inside panels-flexible-13-inside">
<div class="panels-flexible-row panels-flexible-row-13-7 panels-flexible-row-first clear-block ">
  <div class="inside panels-flexible-row-inside panels-flexible-row-13-7-inside panels-flexible-row-inside-first clear-block">
<div class="panels-flexible-region panels-flexible-region-13-js_ panels-flexible-region-first panels-flexible-region-last ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js_-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<div class="panel-pane pane-custom pane-2 " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">

            <div class="warning-banner">
  <h3>
    A new version of this course is available here:
    <br>
    <a href="https://java-programming.mooc.fi/">https://java-programming.mooc.fi/</a>
  </h3>
</div>

<div class="warning-banner-yellow">
  <h3>Warning: This course has migrated to a new server <a href="https://tmc.mooc.fi">https://tmc.mooc.fi</a> (Only affects people using the server <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a>) <br>
    What this means:</h3>
  <ul>
    <li>Old accounts at <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a> will not work anymore. You have to create a new account at <a href="https://tmc.mooc.fi/user/new">https://tmc.mooc.fi</a>.</li>
    <li>Old submissions at <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a> will not be migrated to the new server. Theywill still be visible at the old server for now.</li>
    <li>The old server <a href="https://tmc.mooc.fi/mooc">https://tmc.mooc.fi/mooc</a> will be shut down at some point next year, but there is a brand new Object-Oriented Programming with Java course coming up! This course is just a placeholder between the old and the new course.</li>
    <li>This placeholder course is found at <a href="https://tmc.mooc.fi/org/mooc">https://tmc.mooc.fi/org/mooc</a>. Notice the /org/ part in the middle.</li>
    <li>If you were doing the course on the old server and want to continue where you left off there, please resubmit all your exercises to the new server.</li>
    <li>Remember to change your account name, password and server address in Netbeans' TMC Settings to correspond the account you have on the new server. The correct server address is "https://tmc.mooc.fi/org/mooc".</li>
</ul>
</div>

                    <div class="pane-content content">
                      <h1 class="title">Object-Oriented Programming with Java, part II</h1>        </div>

              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --><div class="panel-region-separator"></div><div class="panel-pane pane-custom pane-3 " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <link href="/2013-oo-programming/menu.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/2013-oo-programming/common-new.css" media="screen, print" rel="stylesheet" type="text/css" />
<link href="/2013-oo-programming/sh_style.css" media="screen, print" rel="stylesheet" type="text/css" />        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
  </div>
</div>
<div class="panels-flexible-row panels-flexible-row-13-4 clear-block js">
  <div class="inside panels-flexible-row-inside panels-flexible-row-13-4-inside clear-block">
<div class="panels-flexible-region panels-flexible-region-13-js_en_ panels-flexible-region-first ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js_en_-inside panels-flexible-region-inside-first">
  </div>
</div>
<div class="panels-flexible-region panels-flexible-region-13-js ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js-inside">
<div class="panel-pane pane-node " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">

<div id="node-222" class="node odd full-node node-type-page">
  <div class="inner">

        <h2 class="title"><a href="/content/js-en" title=""></a></h2>



    <div class="content clearfix">
      <script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/materiaali/javascripts/exercises-eng-new.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/materiaali/javascripts/common-mooc-eng.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/shjs/sh_main.min.js"></script>
<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/shjs/sh_java.min.js"></script>



<script type="text/javascript" src="https://www.cs.helsinki.fi/group/java/k13/ohpe/javascripts/jquery.easing.js"></script>

<div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="1">
          <!-- <span id="materiaali_toc" ></span> -->
          <!--div id="tehtavat_toc" ></div-->
          <!-- <span id="tehtavat_toc2" ></span> -->
        </div>    </div>


      </div><!-- /inner -->

  </div><!-- /node-222 -->
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
<div class="panels-flexible-region panels-flexible-region-13-copyright panels-flexible-region-last float-right">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-copyright-inside panels-flexible-region-inside-last">
<div class="panel-pane pane-custom pane-1 box " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:right;" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a><small>This material is licensed under the Creative Commons BY-NC-SA license, which means that you can use it and distribute it freely so long as you do not erase the names of the original authors. If you do changes in the material and want to distribute this altered version of the material, you have to license it with a similar free license. The use of the material for commercial use is prohibited without a separate agreement.</small></p>        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --><div class="panel-region-separator"></div><div class="panel-pane pane-content-field pane-field-author course-menu " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <div class="field field-type-text field-field-author">
    <div class="field-items">
            <div class="field-item odd">
                    Authors: Arto Hellas, Matti Luukkainen        </div>
        </div>
</div>
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --><div class="panel-region-separator"></div><div class="panel-pane pane-content-field pane-field-translators course-menu " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">
          <div class="field field-type-text field-field-translators">
    <div class="field-items">
            <div class="field-item odd">
                    Translators: Simone Romeo, Kenny Heinonen        </div>
        </div>
        <div class="field-item odd"><br>The course is maintained by the Agile Education Research Group</div>
</div>
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
  </div>
</div>
<div class="panels-flexible-row panels-flexible-row-13-8 panels-flexible-row-last clear-block js en">
  <div class="inside panels-flexible-row-inside panels-flexible-row-13-8-inside panels-flexible-row-inside-last clear-block">
<div class="panels-flexible-region panels-flexible-region-13-js_en panels-flexible-region-first panels-flexible-region-last ">
  <div class="inside panels-flexible-region-inside panels-flexible-region-13-js_en-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<div class="panel-pane pane-node-content box-mooc " >
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
  	<div class="inner-wrapper">
      <div class="inner-inner">



        <div class="pane-content content">

<div id="node-305" class="node even full-node node-type-weekly_tasks">
  <div class="inner">




    <div class="content clearfix">
      <div class="viikkoraja-mooc" id="Week 7" deadline=" " data-first-chapter-index="33" data-first-exercise-index="108" data-first-week-index="7" data-first-chapter-index-mooc="33" data-first-exercise-index-mooc="1" data-first-week-index-mooc="7" tekija="Arto Vihavainen, Matti Luukkainen">


    <h2>Recapping programming basics</h2>

    <p>In this chapter we briefly recap a few concepts we became familiar with in Part 1. You can familiarize yourself with the programming basics course material <a href="http://mooc.fi/courses/2013/programming-part-1/">here</a>.</p>


    <h3>Program, commands and variables</h3>

    <p>A computer program consists of a series of commands that a computer runs one at a time, from top to bottom. The commands always have a predefined structure and semantics. In Java - the programming language we use in this course - the commands are read from top to bottom, left to right. Programming courses are traditionally started by introducing a program that prints the string <code>Hello World!</code>. Below is a command written in Java that prints the <code>Hello World!</code> string.</p>

    <pre class="sh_java">
        System.out.println("Hello World!");
    </pre>

    <p>In the command the method <code>println</code> - which belongs to the <code>System</code> class - gets called, which prints the string passed in to it as a parameter, and after that a linebreak. The method is given the string <code>Hello World!</code> as a parameter; consequently the program prints out <code>Hello World!</code> followed by a linebreak.</p>

    <p>Variables can be used as part of the functionality of the program. Below is a program which introduces the variable <code>length</code> of the integer type. The value 197 is set to this variable on the next line. After this the value <code>179</code> of the variable <code>length</code> is printed.</p>

    <pre class="sh_java">
        int length;
        length = 179;
        System.out.println(length);
    </pre>

    <p>The execution of the program above would happen one line at a time. First the line <code>int length;</code> is executed, in which the variable <code>length</code> is introduced. Next the line <code>length = 179;</code> is executed, in which we set the value <code>179</code> to the variable that was introduced on the previous line. After this the line <code>System.out.println(length);</code> is run, in which we call the print method we saw earlier. To this method we give the variable <code>length</code> as a parameter. The method prints the content - the value - of the variable <code>length</code>, which is <code>179</code>.</p>

    <p>In the program above we really wouldn't have to introduce the variable <code>length</code> on one line and then set its value on the next. The introduction of a variable and setting its value can be done on the same line.</p>

    <pre class="sh_java">
        int length = 179;
    </pre>

    <p>When executing the above line, the variable <code>length</code> is introduced and as it is introduced the value <code>179</code> is set to it.</p>

    <p>In reality all information within a computer is represented as a series of bits - ones and zeros. Variables are an abstraction offered by the programming language with which we can handle different values more easily. The variables are used to store values and to maintain the state of the program. In Java, we have the primitive variable types <code>int</code> (integer), <code>double</code> (floating-point), <code>boolean</code> (truth value), <code>char</code> (character), and the reference variable types <code>String</code> (character string), <code>ArrayList</code> (array), and all classes. We'll return to primitive data type variables and to reference type variables and their differences later.</p>


    <h3>Comparing variables and reading input</h3>

    <p>The functionality of programs is built with the help of control structures. Control structures make different functions possible depending on the variables of the program. Below, an example of an <code>if - else if - else</code> control structure, in which a different function is executed depending on the result of the comparison. In the example a string <code>Accelerate</code> is printed if the value of the variable <code>speed</code> is smaller than 110, the string <code>Break</code> if the <code>speed</code> is greater than 120, and the string <code>Cruising</code> in other cases.</p>

    <pre class="sh_java">
int speed = 105;

if (speed &lt; 110) {
    System.out.println("Accelerate");
} else if (speed &gt; 120) {
    System.out.println("Break");
} else {
    System.out.println("Cruising");
}
    </pre>

    <p>Because in the example above the value of the variable <code>speed</code> is 105, the program will always print the string <code>Accelerate</code>. Remember that the comparison of strings is done with the <code>equals</code> method that belongs to the <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a> class. Below is an example in which an object created from Java's <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a> class is used to read the input of a user. The program checks if the strings entered by the user are equal.</p>

    <pre class="sh_java">
Scanner reader = new Scanner(System.in);

System.out.print("Enter the first string: ");
String first = reader.nextLine();

System.out.print("Enter the second string: ");
String second = reader.nextLine();

System.out.println();

if (first.equals(second)) {
    System.out.println("The strings you entered are the same!");
} else {
    System.out.println("The strings you entered weren't the same!");
}
    </pre>

    <p>The functionality of the program depends on the user's input. Below is an example; the red text is user input.</p>

    <pre>
Enter the first string: <font color="red">carrot</font>
Enter the second string: <font color="red">lettuce</font>

The strings you entered weren't the same!
    </pre>

    <h3>Loops</h3>

    <p>Repetition is often required in programs. First we make a so-called <code>while-true-break</code> loop, which we run until the user inputs the string <code>password</code>. The statement <code>while(true)</code> begins the loop, which will then be repeated until it runs into the keyword <code>break</code>.</p>

    <pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        while (true) {
            System.out.print("Enter password: ");
            String password = reader.nextLine();

            if (password.equals("password")) {
                break;
            }
        }

        System.out.println("Thanks!");
    </pre>


    <pre>
Enter password: <font color="red">carrot</font>
Enter password: <font color="red">password</font>
Thanks!
    </pre>


    <p>You can also pass a comparison to a <code>while</code> loop instead of the boolean <code>true</code>. Below, the user input is printed so that there are stars above and below it.</p>

    <pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter string: ");
        String characterString = reader.nextLine();

        int starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();

        System.out.println(characterString);

        starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();
    </pre>


    <pre>
Enter string: <font color="red">carrot</font>
******
carrot
******
    </pre>

    <p>The example above should make you feel a little bad inside. The bad feelings are hopefully because you see that the example violates the rules learned in the programming basics. The example has unneccessary repetition which should be removed with the help of methods.</p>

    <p>In addition to the while-loop we also have two versions of the <code>for-loop</code> at our disposal. The newer <code>for-loop</code> is used for going through lists.</p>

    <pre class="sh_java">
        ArrayList&lt;String&gt; greetings = new ArrayList&lt;String&gt;();
        greetings.add("Hei");
        greetings.add("Hallo");
        greetings.add("Hi");

        for (String greet: greetings) {
            System.out.println(greet);
        }
    </pre>

    <pre>
Hei
Hallo
Hi
    </pre>

    <p>The more traditional <code>for-loop</code> is used in situations similar to where you would use a <code>while-loop</code>. It can, for example, be used to go through arrays. In the following example all values in the array <code>values</code> will be multiplied by two and then finally printed using the newer <code>for-loop.</code></p>

    <pre class="sh_java">
        int[] values = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; values.length; i++) {
            values[i] = values[i] * 2;
        }

        for (int value: values) {
            System.out.println(value);
        }
    </pre>

    <pre>
2
4
6
8
10
12
    </pre>

    <p>The traditional <code>for-loop</code> is very useful in cases where we go through indices one at a time. The loop below will go through the characters of a character string one by one, and prints the character string <code>Hip!</code> every time we encounter the character <code>a</code>.</p>

    <pre class="sh_java">
        String characterString = "saippuakauppias";
        for (int i = 0; i &lt; characterString.length(); i++) {
            if (characterString.charAt(i) == 'a') {
                System.out.println("Hip!");
            }
        }
    </pre>

    <pre>
Hip!
Hip!
Hip!
Hip!
    </pre>

    <h3>Methods</h3>

    <p>Methods are a way of chopping up the functionality of a program into smaller entities. All Java programs start their execution from the <code>main</code> program method, which is defined with the statement <code>public static void main(String[] args)</code>. This statement defines a static method - that is a method which belongs to the <em>class</em> - which receives a character string array as its parameter.</p>

    <p>The program defines methods to abstract the functionalities of the program. When programming, one should try to achieve a situation in which the program can be looked at from a <em>higher level</em>, in such a case the main method consists of calls to a group of self-defined, well-named methods. The methods then specify the functionality of the program and perhaps are based on calls to other methods.</p>

    <p>Methods that are defined using the keyword <code>static</code> belong to the <em>class</em> that holds the method, and work as so-called support methods. The methods that are defined without the keyword <code>static</code> belong to the instances - <em>the objects</em> - created from the class and can modify the state of that individual object.</p>

    <p>A method always has a visibility modifier (<code>public</code>, visible to 'everyone', or <code>private</code>, only visible within its class), a return type (in the <code>main</code> method this is <code>void</code>, which returns nothing) and a name. In the following code we create a method which belongs to a class, <code>public static void print(String characterString, int times)</code>. This method prints a character string the defined amount of times. This time we use the method <code>System.out.print</code>, which works just like <code>System.out.println</code>, but doesn't print a linebreak.</p>

    <pre class="sh_java">
        public static void print(String characterString, int times) {
            for (int i = 0; i &lt; times; i++) {
                System.out.print(characterString);
            }
        }
    </pre>

    <p>The method above prints the character string it receives as a parameter an amount of times equal to the integer - which was also passed in as a parameter.</p>

    <p>In the section on loops we noticed that the code had some nasty copy-paste stuff in it. With the help of methods, we can move the printing of stars to a separate method. We create a method <code>public static void printStars(int times)</code>, which prints the amount of stars it receives as a parameter. The method uses a <code>for</code> loop instead of a <code>while</code>.</p>

    <pre class="sh_java">
        public static void printStars(int times) {
            for (int i = 0; i &lt; times; i++) {
                System.out.print("*");
            }
            System.out.println();
        }
    </pre>

    <p>When making use of a method, our previous (and hideous) example now looks like the following.</p>

    <pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter characterString: ");
        String characterString = reader.nextLine();

        printStars(characterString.length());
        System.out.println(characterString);
        printStars(characterString.length());

    </pre>


    <h3>Class</h3>

    <p>Methods can abstract a program up to a certain point, but as the program becomes larger it's sensible to chop down the program even further into smaller and more logical entities. With the help of classes, we can define higher level concepts of a program and functionalities related to those concepts. Every Java program requires a class in order to work, so the <code>Hello World!</code> example wouldn't work without the class definition. A class is defined with the keywords <code>public class nameOfTheClass</code>.</p>

    <pre class="sh_java">
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
    </pre>

    <p>In a program, classes are used to define concepts and functionalities related to those concepts. Objects can be created from a class and are the embodiments of that class. Every object that belongs to a certain class has the same structure, but the variables belonging to each objects can be different. The methods of objects handle the <em>state</em> of the object, that is, the variables of the object.</p>

    <p>Let's inspect the class <code>Book</code> below; the class has the object variables <code>name</code> (String) and <code>publishingYear</code> (integer).</p>

    <pre class="sh_java">
        public class Book {
            private String name;
            private int publishingYear;

            public Book(String name, int publishingYear) {
                this.name = name;
                this.publishingYear = publishingYear;
            }

            public String getName() {
                return this.name;
            }

            public int getPublishingYear() {
                return this.publishingYear;
            }
        }
    </pre>

    <p>The definition in the beginning, <code>public class Book</code>, tells the name of the class. This is followed by the definitions of object variables. Object variables are variables which for each of the objects created from the class are their own -- the object variables of one object are unrelated to the state of the same variables of another object. It's usually appropriate to hide the object variables from the users of the class, to define the visibility modifier <code>private</code> for them. If the visibility modifier is set to <code>public</code>, the user of the object will be able to directly access the object variables.</p>

    <p>Objects are created from a class with a <em>constructor</em>. A constructor is a method that initializes an object (creates the variables belonging to the object) and executes the commands that are within the constructor. The constructor is always named the same as the class that has the constructor in it. In the constructor <code>public Book(String name, int publishingYear)</code> a new object is created from the class <code>Book</code> and its variables are set to the values that were passed in as parameters.</p>

    <p>Two methods that handle the information in the object are also defined for the class above. The method <code>public String getName()</code> returns the name of the object in question. The method <code>public int getPublishingYear()</code> returns the publishing year of the object in question.</p>

    <h3>Object</h3>

    <p><em>Objects</em> are created with the help of the constructor that is defined within a class. In the program code the costructor is called with the <code>new</code> command, which returns a reference to the new object. Objects are instances created from classes. Let's inspect a program that creates two different books, after which it prints the values returned by the <code>getName</code> methods belonging to the objects.</p>

    <pre class="sh_java">
        Book senseAndSensibility = new Book("Sense and Sensibility", 1811);
        Book prideAndPrejudice = new Book("Pride and Prejudice", 1813);

        System.out.println(senseAndSensibility.getName());
        System.out.println(prideAndPrejudice.getName());
    </pre>

    <pre>
Sense and Sensibility
Pride and Prejudice
    </pre>

    <p>So, each object has its own internal state. The state is formed from object variables that belong to the object. Object variables can be both primitive type variables and reference type variables. If reference type variables belong to the objects, it is possible that other objects also refer to the same referenced objects! Let's visualize this with the bank example, in which there are accounts and persons.</p>

    <pre class="sh_java">
        public class Account {
            private String accountID;
            private int balanceAsCents;

            public Account(String accountID) {
                this.accountID = accountID;
                this.balanceAsCents = 0;
            }

            public void deposit(int sum) {
                this.balanceAsCents += sum;
            }

            public int getBalanceAsCents() {
                return this.balanceAsCents;
            }

            // .. other methods related to an account
        }
    </pre>

    <pre class="sh_java">
        import java.util.ArrayList;

        public class Person {
            private String name;
            private ArrayList&lt;Account&gt; accounts;

            public Person(String name) {
                this.name = name;
                this.accounts = new ArrayList&lt;Account&gt;();
            }

            public void addAccount(Account account) {
                this.accounts.add(account);
            }

            public int moneyTotal() {
                int total = 0;
                for (Account account: this.accounts) {
                    total += account.getBalanceAsCents();
                }

                return total;
            }

            // ... other methods related to a person
        }
    </pre>

    <p>Each object created from the <code>Person</code> class has its own name and its own list of accounts. Next, let's create two persons and two accounts. One of the accounts is owned by only one person and the other one is shared.</p>

    <pre class="sh_java">
        Person matti = new Person("Matti");
        Person maija = new Person("Maija");

        Account salaryAccount = new Account("NORD-LOL");
        Account householdAccount = new Account("SAM-LOL");

        matti.addAccount(salaryAccount);
        matti.addAccount(householdAccount);
        maija.addAccount(householdAccount);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        salaryAccount.deposit(150000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        householdAccount.deposit(10000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();
    </pre>

    <pre>
Money on Matti's accounts: 0
Money on Maija's accounts: 0

Money on Matti's accounts: 150000
Money on Maija's accounts: 0

Money on Matti's accounts: 160000
Money on Maija's accounts: 10000
    </pre>

    <p>Initially, the accounts of both persons are empty. When money is added to the salaryAccount - which <code>matti</code> has a reference to - the amount of money on Matti's accounts grows. When money is added to the householdAccount <em>the amount of money each person has grows</em>. This is because both Matti and Maija have "access" to the householdAccount, so in each of the persons' object variable <code>accounts</code>, there's a reference to the householdAccount.</p>


    <h3>The structure of a program</h3>

    <p>A program should be clear and easy to understand for both the original writer and others. The most important aspects of a clear program are class structure and good naming conventions. Each class should have a single, clearly defined responsibility. Methods are used to reduce repetition and to create a structure for the internal functionality of the class. A method should also have a clear responsibility to ensure it stays short and simple. Methods that do many things should be divided into smaller helper methods, which are called by the original method. A good programmer writes code that can be understood even weeks after it was originally written.</p>

    <p>Good, understandable code uses descriptive naming of variables, methods and classes, and consistent indentation. Let's look at the example below, a small program for buying and selling goods. Even though the only thing available is carrots, with no bookkeeping, the user interface could be extended to use a storage class to keep track of items.

    </p><pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else if (command.equals("buy")) {
                String line = null;
                while(true) {
                    System.out.print("What to buy: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Bought!");
            } else if (command.equals("sell")) {
                String line = null;
                while(true) {
                    System.out.print("What to sell: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Sold!");
            }
        }
    }
}
    </pre>

    <p>This example has numerous problems. The first problem is the long <code>start</code> method. It can be shortened by moving most of the command handling to a separate method.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String line = null;
            while(true) {
                System.out.print("What to buy: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String line = null;
            while(true) {
                System.out.print("What to sell: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Sold!");
        }
    }
}
    </pre>

    <p><code>handleCommand</code> still has some repetition for reading the user input. Both buying and selling first print a character string with the question, then take input from the user. If the input is incorrect (other than "carrot"), "Item not found!" is printed. We will create a new method, <code>public String readInput(String question)</code>, to handle this. Note that if the program used some other object to keep track of inventory, we would compare user input to the inventory's contents instead.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
    </pre>

    <p>The program is now divided into appropriate parts. There are still a few things, other than implementing more methods, we can do to improve readability. The <code>start</code> method has an <code>if</code> branch that ends in <code>break</code>, which exits the loop. We can remove the unnecessary <code>else</code> branch, simply moving the <code>handleCommand</code> method to be called after the <code>if</code> statement. The program still works exactly as before, but the method is now shorter and easier to read. A similar situation exists in the <code>readInput</code> method, so we will clean it up too.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }

            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            }

            System.out.println("Item not found!");
        }
    }
}
    </pre>


    <p>Dividing a program into smaller parts, like we did above, is called <em>refactoring</em>. It does not change how the program works, but the internal structure is changed to be more clear and easier to maintain. The current version is clearer than the original, but it can be improved further. For example, <code>handleCommand</code> can be further divided into two different methods, one for handling buying and the other for selling.</p>

    <pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }

            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            commandBuy();
        } else if (command.equals("sell")) {
            commandSell();
        }
    }

    public void commandBuy() {
        String input = readInput("What to buy: ");
        System.out.println("Bought!");
    }

    public void commandSell() {
        String input = readInput("What to sell: ");
        System.out.println("Sold!");
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
    </pre>

    <p>The program now has a clear structure with descriptively named methods. Every method is short and has a small task to handle. Note that refactoring the code did not add any new functionality, it merely changed the way the program works internally.</p>

    <h3>Programming and the importance of practicing</h3>

    <p>As far as we know, nobody has yet learned programming by listening to lectures. To develop the skill required in programming, it is essential to practice both what you have learned earlier and things that are new to you. Programming can be compared to speaking languages or playing an instrument, both of which can only be learned by doing. Master violinists are probably not good at playing <em>only</em> because they practice a lot. Playing an instrument is fun, which makes one more motivated to practice. The same applies to programming.</p>

    <p>As Linus Torvalds said, <em>"Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program"</em>.</p>

    <p>Dr. Luukkainen has written a list of instructions for new programmers to follow when learning to program. Follow this advice to become a great programmer!</p>

    <ul><li> Take small steps
      <ul><li> Divide the problem you are trying to solve into smaller parts and solve them <strong>one at a time</strong> </li>
        <li> Keep testing that your solution is moving in the right direction, ensuring that you have solved the current part correctly</li>
      </ul></li>
      <li> Keep the code as clean as you can
      <ul><li> use proper indentation </li>
        <li> use descriptive names for variables, methods, classes, everything</li>
        <li> keep all methods short, including <code>main</code> </li>
        <li> write methods that only do one thing </li>
        <li> <strong>remove all copy-paste code by refactoring (or don't copy and paste code in the first place!)</strong></li>
        <li> replace "bad" and unclear code with clean, easy to read code </li>
      </ul></li>
    </ul><h3>Visibility</h3>

    <p>Until now, we have been using two different keywords to define the <em>visibility</em> of methods and instance variables. <code>public</code> makes the method or instance variable visible and accessable to everyone. Methods and constructors are usually marked as public, so that they can be called from outside the class.</p>

    <p>Declaring a method or instance variable <code>private</code> hides it from the outside, making it only accessible from inside the same class.</p>

    <pre class="sh_java">
public class Book {
    private String name;
    private String contents;

    public Book(String name, String contents) {
        this.name = name;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public String getContents() {
        return this.contents;
    }

    // ...
}
    </pre>

    <p>The instance variables in the Book class above can only be accessed with the public methods <code>getName</code> and <code>getContents</code>. Fields declared as private are only accessible in code inside the class. Methods can also be declared as private, which prevents them from being called outside the class.</p>


    <p>Now it's time to start practicing!</p>

    <div class="tehtavat" id="viikko7">
      <div class="tehtava">
        <h3>Smileys</h3>

        <p>Create the support method <code>private static void printWithSmileys(String characterString)</code> for the class <code>Smileys</code> which comes with the assignment template. The method is to print the given character string surrounded with smileys. Use the character string <code>:)</code> as the smiley.</p>

        <pre class="sh_java">
printWithSmileys("\\:D/");
        </pre>

        <pre>
:):):):):)
:) \:D/ :)
:):):):):)
        </pre>

        <p>Note, that the character string must have \\ so we can print the symbol \.</p>

        <p><em>Note!</em> if the length of the character string is an odd number, add an extra space on the right side of the given character string.</p>

        <pre class="sh_java">
printWithSmileys("\\:D/");
printWithSmileys("87.");
        </pre>

        <pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
        </pre>

        <p>It's a good idea to first think how many smileys should be printed for a character string of a certain length. The length of a character string can be found out with the method <code>length</code> which belongs to it. A loop is helpful for printing the top and bottom smiley rows, the middle row can be handled with a normal print command. You can check if a length is an odd number with the help of a remainder <code>characterString.length() % 2 == 1</code>.</p>
      </div>
      <div class="tehtava">
        <h3>Character String Changer</h3>

        <p>In this assignment we create a character string changer, which consists of two classes. The class <code>Changer</code> turns a single character to another one. The Changer holds a number of Changes and changes character strings with the help of Change objects it holds.</p>

        <h4>Change-class</h4>

        <p>Create a class <code>Change</code>, that has the following functionalities:</p>

        <ul><li> constructor <code>public Change(char fromCharacter, char toCharacter)</code> that creates an object that makes changes from character <code>fromCharacter</code> to <code>toCharacter</code></li>
          <li> method <code>public String change(String characterString)</code> returns the changed version of the given character string</li>
        </ul><p>The class is used in the following way:</p>

        <pre class="sh_java">
  String word = "carrot";
  Change change1 = new Change('a', 'b');
  word = change1.change(word);

  System.out.println(word);

  Change Change2 = new Change('r', 'x');
  word = Change2.change(word);

  System.out.println(word);
        </pre>

        <p>The example above would print:</p>

        <pre>
  cbrrot
  cbxxot
        </pre>

        <p><strong>Tip:</strong> you can handle replacing characters in two ways, either with the help of a method in the class <code>String</code> (look for it yourself!) or by going through the character string character by character while forming the changed character string.</p>

        <p>If you don't use the ready-made method of String, it is good to remember that even though you compare character strings with the command <code>equals</code> you compare single characters with the == operator:</p>

        <pre class="sh_java">
  String word = "carrot";

  String replacedA = "";
  for ( int i=0; i &lt; word.length(); i++) {
     char character = word.charAt(i);
     if ( character == 'a' ) {
        replacedA += '*'
     }  else {
        replacedA += character;
     }
  }

  System.out.println(replacedA);  // prints c*rrot
        </pre>

        <h4>Changer-class</h4>

        <p>Create the class <code>Changer</code>, with the following functions:</p>

        <ul><li> constructor <code>public Changer()</code> creates a new changer</li>
          <li> method <code>public void addChange(Change change)</code> adds a new Change to the Changer</li>
          <li> method <code>public String change(String characterString)</code> executes all added Changes for the character string in the order of their adding and returns the changed character string</li>
        </ul><p>The class is used in the following way:</p>

        <pre class="sh_java">
  Changer scandiesAway = new Changer();
  scandiesAway.addChange(new Change('ä', 'a'));
  scandiesAway.addChange(new Change('ö', 'o'));
  System.out.println(scandiesAway.change("ääliö älä lyö, ööliä läikkyy"));
        </pre>

        <p>The above example would print:</p>

        <pre>
  aalio ala lyo, oolia laikkyy
        </pre><!-- TODO -->

        <p><strong>Tip:</strong> It's a good idea to store the Changes to a list object variable of Changer (in the same fashion as on the basics course we stored players to a team, phone numbers to a phone book or books to a library, for example) A Changer is executed so that the changes are done to the character string one at a time as in the following example:</p>

        <pre class="sh_java">
    ArrayList&lt;Change&gt; changes = new ArrayList&lt;Change&gt;();

    changes.add( new Change('a', 'b') );
    changes.add( new Change('k', 'x') );
    changes.add( new Change('o', 'å') );

    String word = "carrot";

    for (Change Change : changes) {
        word = Change.change(word);
    }

    System.out.println(word);  // print pårxxbnb
        </pre>

        <p><strong>REMINDER</strong> when you add an ArrayList, a Scanner or a Random, Java doesn't recognize the class unless you "import" it by adding the following lines to the beginning:</p>

        <pre class="sh_java">
import java.util.ArrayList;    // imports ArrayList
import java.util.*;            // imports all tools from java.util, including ArrayList, Scanner ja Random
        </pre>
      </div>
      <div class="tehtava">
        <h3>Calculator</h3>

        <p>In this assignment, we make a simple calculator, similar to the one made in the material of programming basics' week 1. This time however, we pay attention to the structure of the program. Especially we will make the <em>main</em>-method (the main program) very light. The main program method doesn't actually do anything else than just start the program:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        calculator.start();
    }
}
        </pre>

        <p>What the main program here does is it just creates the object that implements the actual application logic and then starts it. This is the proper way of creating programs and from now on we'll try to achieve this structure.</p>

        <h4>Reader</h4>

        <p>In order to communicate with the user, the calculator needs a Scanner-object. As we've seen, reading integers with a Scanner is a little laborious. We now create a separate class <code>Reader</code> that encapsulates a Scanner-object.</p>

        <p>Implement the class <code>Reader</code> and add the following methods to it</p>

        <ul><li><code>public String readString()</code></li>
          <li><code>public int readInteger()</code></li>
        </ul><p>Within the Reader there should be a Scanner-object as an instance variable, which the methods use in the old familiar way we know from programming basics. Remember that when reading integers, it's good to first read the entire line and then turn that in to an integer. Here we can utilize the method <code>parseInt</code> of the <code>Integer</code>-class.</p>

        <h4>Application body</h4>

        <p>The calculator works like this:</p>

        <pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
        </pre>

        <p>Implement the class <code>Calculator</code> to take care of the application logic of your program, and for that class a method <code>public void start()</code> which looks exactly like this:</p>

        <pre class="sh_java">
    public void start() {
        while (true) {
            System.out.print("command: ");
            String command = reader.readString();
            if (command.equals("end")) {
                break;
            }

            if (command.equals("sum")) {
                sum();
            } else if (command.equals("difference")) {
                difference();
            } else if (command.equals("product")) {
                product();
            }
        }

        statistics();
    }
        </pre>

        <p>The calculator has the operations <code>sum, difference, product</code>.</p>

        <p>Finish the bodies for the methods <code>sum</code>, <code>difference</code>, <code>product</code> and <code>stasistics</code>. All of them are to be of the type <code>private void</code> which means that the methods are available only for internal use in the calculator.</p>

        <p>Add an instance variable of the type <code>Reader</code> for the calculator and create the reader in the constructor. <em>The calculator may not have a separate Scanner-type variable!</em></p>

        <h4>Implementation of the application logic</h4>

        <p>Now implement the methods <code>sum</code>, <code>difference</code> and <code>product</code> so that they work according to the example above. In the example, first a command is asked from the user and then two values. The desired operation is then executed and the value of the operation is printed. Notice that asking the user for the values happens within the methods <code>sum</code>, <code>difference</code> and <code>product</code>! The methods use the Reader-object to ask the values, so the body of the methods is as follows:</p>

        <pre class="sh_java">
    private void sum() {
       System.out.print("value1: ");
       int value1 = // read the value using the Reader-object
       System.out.print("value2: ");
       int value2 = // read the value using the Reader-object
       // print the value according to the example above
    }
        </pre>

        <h4>Statistics</h4>

        <p>After the <code>while</code>-loop in the <code>start</code>-method, the method <code>statistics</code> is called. The method is meant to print the amount of operations done with the Calculator-object:</p>

        <pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
Calculations done 2
        </pre>

        <p>Implement the method <code>private void statistics()</code>, and make the required changes to the code of the Calculator-class in order to collect the statistics.</p>

        <p>Note: if an invalid command is given to the program (something other than sum, difference, product or end), the calculator will not react to the command in any way, but instead continues by asking the next command. Statistics is not to count an invalid command as a completed calculation.</p>

        <pre>
command: <font color="red">integral</font>
command: <font color="red">difference</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
difference of the values 1

command: <font color="red">end</font>
Calculations done 1
        </pre>

        <p><strong>Bonus assignment (not tested):</strong> Reading the user input is repeated in the same way in all three operation implementing methods. Remove the repetition from your code with the help of a support method. The method can return the two values asked from the user in an array, for example.</p>

      </div>
    </div>


    <h2>Primitive- and reference-type variables</h2>

    <p>Java is a strongly typed language, what this means is that all of its variables have a <em>type</em>. The types of the variables can be divided in to two categories: <strong>primitive-type and reference-type variables</strong>. Both types of variables have their own "slot", which holds the information belonging to them. Primitive-type variables hold the concrete <em>value</em> in their slot, while the reference-type variables hold a <em>reference</em> to a concrete <em>object</em>.</p>

    <h3>Primitive-type variables</h3>

    <p>The value of a primitive type variable is saved in a slot created for the variable. Each primitive-type variable has its own slot and its own value. A variable's slot is created when it is introduced (<code>int number;</code>, for example). A value is set to a slot with the assignment operator <code>=</code>. Below is an example of the introduction of a primitive-type <code>int</code> (integer) variable and setting of its value in the same expression.</p>

    <pre class="sh_java">
int number = 42;
    </pre>

    <p>Primtive type variables, among others, are <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> and the more rarely used <code>short</code>, <code>float</code>, <code>byte</code> and <code>long</code>. Another primitive-type is <code>void</code>, but it doesn't have its own slot or value. The <code>void</code>-type is used when we want to express that a method doesn't return a value.</p>

    <p>Next we introduce two primitive-type variables and set values to them.</p>

    <pre class="sh_java">
int five = 5;
int six = 6;
    </pre>

    <p>The primitive-type variables introduced above are named <code>five</code> and <code>six</code>. When introducing the variable <code>five</code> the value 5 is set to the <em>slot</em> that was created for it (<code>int five = 5;</code>).  When introducing the variable <code>six</code> the value 6 is set to the <em>slot</em> that was created for it (<code>int six = 6;</code>). The variables <code>five</code> and <code>six</code> are both of the type <code>int</code>, or integers.</p>

    <p>Primitive-type variables can be visualized as boxes that both have the values belonging to them saved in to them:</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/primitive-five-and-six.png"/></p>

    <p>Next lets inspect how the values of primitive-type variables get copied.</p>

    <pre class="sh_java">
int five = 5;
int six = 6;

five = six; // the variable 'five' now holds the value 6 - the value that was in the variable 'six'.
six = 64; // the variable 'six' now holds the value 64

// the variable 'five' still holds the value 6
    </pre>

    <p>Above we introduce the variables <code>five</code> and <code>six</code> and we set values to them. After this the value held in the slot of the variable <code>six</code> is copied to the slot of the variable <code>five</code> (<code>five = six;</code>). If the value of the variable <code>six</code> is changed after this point the value in the variable <code>five</code> remains unaffected: the value of the variable <code>five</code> is in its own slot and is not related to the value in the slot of the variable <code>six</code> in any way. The end situation as a picture:</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/primitive-five-and-six-64.png"/></p>

    <h4>Primitive type variable as a method parameter and return value</h4>

    <p>When a primitive type variable is passed to a method as a parameter, the method parameter is set to the value in the given variable's slot. In practice, the method parameters also have their own slots to which the value is copied, like in an assignment expression. Let us consider the following method <code>addToValue(int value, int amount)</code>.</p>

    <pre class="sh_java">
public int addToValue(int value, int amount) {
    return value + amount;
}
    </pre>

    <p>The method <code>addToValue</code> is given two parameters: <code>value</code> and <code>amount</code>. The method returns a new value, which is the sum of the given parameters. Let us investigate how the method is called.</p>

    <pre class="sh_java">
int myValue = 10;
myValue = addToValue(myValue, 15);
// the variable 'myValue' now holds the value 25
    </pre>

    <p>In the example, <code>addToValue</code> is called using the variable <code>myValue</code> and the value <code>15</code>. These are copied to the method parameters <code>value</code>, which will hold the value 10 (the contents of <code>myValue</code>), and <code>amount</code>, which wil hold the value 15. The method returns the sum of <code>value</code> and <code>amount</code>, which is equal to <code>10 + 15 = 25</code>.</p>

    <p>Note! In the previous example, the value of the variable <code>myValue</code> is changed only because it is assigned the return value of <code>addToValue</code> (<code>myValue = addToValue(myValue, 15);</code>). If the call to <code>addToValue</code> were as follows, the value of the variable <code>myValue</code> would remain unchanged.</p>

    <pre class="sh_java">
int myValue = 10;
addToValue(myValue, 15);
// the variable 'myValue' still holds the value 10
    </pre>

    <h4>Minimum and maximum values</h4>

    <p>Each primitive data type can represent a specific range of values limited by its minimum and maximum value, which are the smallest and largest values representable by the type. This is because a predefined data size is used for the internal represetantion of the type in Java (and most other programming languages).</p>

    <p>The minimum and maximum values for a few Java primitive types are:</p>

    <p>
    </p><table cellspacing="5"><tr><th>Data type</th><th>Description</th><th>Minimum value</th><th>Max value</th></tr><tr><td>int</td><td>Integer</td><td>-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td><td>2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td></tr><tr><td>long</td><td>Long interger</td><td>-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td><td>9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td></tr><tr><td>boolean</td><td>Truth value</td><td colspan="2"><code>true</code> or <code>false</code></td></tr><tr><td>double</td><td>Floating point</td><td><code>Double.MIN_VALUE</code></td><td><code>Double.MAX_VALUE</code></td></tr></table><p><strong>Rounding errors</strong></p>

    <p>When using floating point data types, it is important to keep in mind that floating point types are always an <em>approximation</em> of the actual value. Because floating point types use a predefined data size to represent the value similarly to all other primitive data types, we may observe quite surprising rounding errors. For example, consider the following case.</p>

    <pre class="sh_java">
double a = 0.39;
double b = 0.35;
System.out.println(a - b);
    </pre>

    <p>The example prints the value <code>0.040000000000000036</code>. Programming languages usually include tools to more accurately handle floating point numbers. In Java, for example, the class <em>BigDecimal</em> can be used to store infinitely long floating point numbers.</p>

    <p>When comparing floating point numbers, rounding errors are usually taken into account by comparing the distance between the values. For example, with the variables in the previous example, the expression <code>a - b == 0.04</code> does not produce the expected result due to a rounding error.</p>

    <pre class="sh_java">
double a = 0.39;
double b = 0.35;

if((a - b) == 0.04) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
    </pre>

    <pre>
Failed comparison!
    </pre>

    <p>One method to calculate the distance between two values is as follows. The helper function <code>Math.abs</code> returns the absolute value of the value passed to it.</p>

    <pre class="sh_java">
double a = 0.39;
double b = 0.35;

double distance = 0.04 - (a - b);

if(Math.abs(distance) &lt; 0.0001) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
    </pre>
    <pre>
Successful comparison!
    </pre>
    <h3>Reference-Type Variables</h3>

    <p>Reference-type variables memorize the information which has been assigned to them "on the other end of the line". Reference-type variables contain a reference to the location where the information is stored. Differently from primitive-type variables, reference-type variable do not have a limited scope because their value or <em>information</em> is stored at the referenced location. Another substantial difference between primitive-type and reference-type variables is that various different reference-type variables can point to the same object.</p>

    <!--
        <p>Reference-type variables are objects which are created through the <code>new</code> keyword. The value of a reference-type variable is still assigned using the operator <code>=</code>; however, the <code>new</code> operator creates an object and returns the reference to that object. The reference is stored within the variable, and it becomes its value.</p>
-->

    <p>Let us have a look at two reference-type variables. In the following examples we make use of the class <em>Calculator</em>:</p>

    <pre class="sh_java">
public class Calculator {
    private int value;

    public Calculator(int originalValue) { // Contructor
        this.value = originalValue;
    }

    public void increaseValue() {
        this.value = this.value + 1;
    }

    public int getValue() {
        return value;
   }
}
    </pre>

    <p>Main:</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);
    </pre>

    <p>In the examples we first create a reference-type variable called <code>bonusCalculator</code>. The <code>new</code> operator tells that we define storage space for the information to be assigned to the variable, then we execute the code which follows the <code>new</code> operator, and we return a reference to the object that has been so created. The reference which is returned is assigned to the <code>bonusCalculator</code> variable through the <code>=</code> equal sign. The same thing happens with the variable called <code>axeCalculator</code>. If we want to think about it with pictures, we can imagine a reference-type variable as it were a box, the variable itself, with a line or an arrow, which starts at the box and points to an object. In fact, the variable does not contain the object, but it points to the object information. </p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators.png"/></p>

    <p>Next, let us have a look at how a reference-type object is duplicated.</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                                 // that is to say, a reference to a Calculator-type object which received the value 6 in its constructor
                                 // is copied to the variable bonusCalculator
    </pre>

    <p>When we copy a reference-type variable (see above <code>bonusCalculator =  axeCalculator;</code>), the reference to the variable duplicates as well. In this case, a reference to the <code>axeCalculator</code> variable slot is copied to the <code>bonusCalculator</code> variable slot. Now, both the objects point to the same place!</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators-ref-changed.png"/></p>

    <p>Let us continue with the example above and let us set a new reference to the variable <code>axeCalculator</code>; this new reference will point to a new object created by the command <code>new Calculator(10)</code>.</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                                 // that is to say, a reference to a Calculator-type object which received the value 6 in its constructor
                                 // is copied to the variable

axeCalculator = new Calculator(10); // a new reference is assigned to the axeCalculator variable
                                    // which points to the object created by the command new Calculator(10)

// the bonusCalculator variable still contains a reference to the Calculator object which received value 6 in its parameter
    </pre>

    <p>In these examples, we do the same operations which were shown in the assignment example in the primitive-type variables section. In the very last example, we copied the reference of reference-type variables, whereas in the primitive-type variables section we copied the value of primitive-type variables. In both cases, we copy the contents of a slot: the primitive-type variable slot contains a value, whereas the reference-type variable slot contains a reference.</p>

    <p>At the end of the previous example no variable points to the Calculator object which received value 5 in its constructor. Java's garbage collection deletes such useless objects from time to time. Our final situation looks like the following:</p>


    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators-3rd-object.png"/></p>

    <p>Let us have a look to a third example still, and let us focus on an essential difference between primitive-type and reference-type variables.</p>

    <pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                                 // that is to say, a reference to a Calculator-type object which received the value 6 in its constructor
                                 // is copied to the variable

axeCalculator.increaseValue(); // we increase by one the value of the object referenced by axeCalculator

System.out.println(bonusCalculator.getValue());
System.out.println(axeCalculator.getValue());
    </pre>

    <pre>
7
7
    </pre>

    <p>Both <code>bonusCalculator</code>and <code>axeCalculator</code> point to the same object, after we have run the command <code>bonusCalculator = axeCalculator;</code>, and therefore, now they both have the same value 7, even though we have increased only one of them.</p>

    <p>The situation might be clear if we look at the following picture. The method <code>axeCalculator.increaseValue()</code> increases by one the <code>value</code> variable of the object pointing to the <code>axeCalculator</code> variable. Because <code>bonusCalculator</code> points to the same object, the method <code>bonusCalculator.getValue()</code> returns the same value which was increased by the method <code>axeCalculator.increaseValue()</code>.</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/reference-type-calculators-val-changed.png"/></p>

    <p>In the following example, three reference-type variables all point to the same <code>Calculator</code> object.</p>

    <pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;
    </pre>

    <p>In the example, we create only one <code>Calculator</code> object, but all the three <code>Calculator</code> variables point to that same one. Therefore, <code>bonus</code>, <code>ihq</code>, and <code>lennon</code> method calls all modify the same object. To tell it once again: when reference-type variables are copied, their references also duplicate. The same concept in a picture:</p>


    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/three-calculators-1.png"/></p>

    <p>Let's use this example to focus on duplication once more.</p>

    <pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;

lennon = new Calculator(3);
    </pre>

    <p>The modification of the <code>lennon</code> variable contents – that is to say the change of reference – does not affect the references of either <code>bonus</code> or <code>ihq</code>. When we assign a value to a variable, we <em>only</em> change the contents of that variable's own slot. The same concept in a picture:</p>

    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/three-calculators-2.png"/></p>

    <h4>A Reference-Type Variables and Method Parameters</h4>

    <p>When a reference-type variable is given to a method as its parameter, we create a method parameter which is the copy of the reference of a variable. In other words, we copy the reference to the parameter's own slot. Differently from what happens with original-type variables, we copy the reference and not their value. In fact, we can modify the object behind the reference even from within the method. Let us take the method <code>public void addToCalculator(Calculator calculator, int amount)</code>.</p>

    <pre class="sh_java">
public void addToCalculator(Calculator calculator, int amount) {
    for (int i = 0; i &lt; amount; i++) {
        calculator.increaseValue();
    }
}
    </pre>

    <p>We give two parameters to the method <code>addToCalculator</code> – a reference-type value and an original-type variable. The contents of both variable slots are copied to method parameter slots. The reference-type parameter <code>calculator</code> receives a copy of a reference, whereas the original-type parameter <code>amount</code> receives the copy of value. The method will call the <code>increaseValue()</code> method of the <code>Calculator</code>-type parameter, and it will do it as many times as the value of the <code>amount</code> variable. Let us analyze the method call a little more deeply.</p>

    <pre class="sh_java">
int times = 10;

Calculator bonus = new Calculator(10);
addToCalculator(bonus, times);
// the bonus variable value is now 20
    </pre>

    <p>In the example we call the <code>addToCalculator</code> method, whose given variables are <code>bonus</code> and <code>times</code>. This means that the reference of the reference-type variable <code>bonus</code> and the value of the original-type variable <code>times</code>  (which is <code>10</code>) are copied as parameters whose names are <code>calculator</code> and <code>amount</code>, respectively. The method executes the <code>increaseValue()</code> method of the <code>calculator</code> variable a number of times which equals the value of <code>amount</code>. See the following picture:</p>


    <p><img src="https://raw.github.com/UniversityHelsinkiTKTL/MOOC-material/master/img/advprog/refs-main-and-method-world.png"/></p>

    <p><em>The method contains variables which are completely separated from the main program!</em></p>

    <p>As far as the reference-type variable is concerned, a reference duplicates and it is given to the method, and the variable inside the method will still point to the same object. As far as the original-type variable is concerned, a value is copied, and the variable inside the method will have its completely independent value.</p>

    <p>The method recognises the calculator which the <code>bonus</code> variable points to, and the alterations made by the method have a direct impact on the object. The situation is different with original-type variables, and the method only receives a copy of the value of the <code>times</code> variable. In fact, it is not possible to modify the value of original-type variables directly within a method.</p>

    <h4>A method which returns a reference-type variable</h4>

    <p>When a method returns a reference-type variable, it returns the reference to an object located elsewhere. Once the reference is returned by a method, it can be assigned to a variable in the same way as a normal assignment would happen, through the equal sign (=). Let us have a look at the method <code>public Calculator createCalculator(int startValue)</code>, which creates a new reference-type variable.</p>

    <pre class="sh_java">
public Calculator createCalculator(int startValue) {
    return new Calculator(startValue);
}
    </pre>

    <p>The creteCalculator method creates an object and returns its <code>newCalculator</code> reference. By calling the method, we always create a new object. In the following example we create two different <code>Calculator</code>-type objects.</p>

    <pre class="sh_java">
Calculator bonus  = createCalculator(10);
Calculator lennon = createCalculator(10);
    </pre>

    <p>The method <code>createCalculator</code> always creates a new <code>Calculator</code>-type object. With the first call, <code>Calculator bonus  = createCalculator(10);</code> we assign the method return reference to the <code>bonus</code> variable. With the second call, we create another reference and we assign it to the <code>lennon</code> variable. The variables <code>bonus</code> and <code>lennon</code> do not contain the same reference because the method creates a new object in both cases, and it returns the reference to that particular object.</p>


    <h2 id="stat_ja_ei">Static and Non-Static</h2>


    <p>Let's further investigate a topic we introduced in the 30th section of Introduction to Programming. The static or non-static nature of a variable or of a method depends on their scope. Static methods are always related to their class, whereas non-static methods can modify the variables of the object itself.</p>

    <h3>Static, Class Libraries and Final</h3>

    <p>The methods which receive the definition static are not related to objects but to classes. it is possible to define class-specific variables by adding the word <code>static</code> to their name. For instance, <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code> and <code>Double.MAX_VALUE</code> are all static methods. Static methods are called via their class name, for instance <code>ClassName.variable</code> or <code>ClassName.method()</code>.</p>

    <p>We call <em>class library</em> a class which contains common-use methods and variables. For instance, Java <code>Math</code> class is a class library. It provides the <code>Math.PI</code> variable, inter alia. Often, creating your own class libraries can prove useful. Helsinki Regional Transport Authority (Finnish: Helsingin Seudun Liikenne, HSL) could use a class library to keep its ticket prices at its fingertips.</p>

    <pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_ADULT = 2.50;
    public static final double TRAMTICKET_ADULT = 2.50;
}
    </pre>

    <p>The keyword <code>final</code> in the variable definition tells that once we assign a value to a variable, we can not assign a new one to it. Final-type variables are constant, and they always have to have a value. For instance, the class variable which tells the greatest integer, <code>Integer.MAX_VALUE</code>, is a constant class variable.</p>

    <p>Once we have the class presented above, <code>HslPrices</code>, all the programs which need the single or tram-ticket price can have access to it through the class <code>HslPrices</code>. With the next example, we present the class <code>Person</code>, which has the method <code>enoughMoneyForSingleTicket()</code>, which makes use of the ticket price found in the class <code>HslPrices</code>.</p>

    <pre class="sh_java">
public class Person {
    private String name;
    private double money;
    // more object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.money &gt;= HslPrices.SINGLETICKET_ADULT) {
            return true;
        }

        return false;
    }

    // the other methods regarding the class Person
}
    </pre>

    <p>The method <code>public boolean enoughMoneyForSingleTicket()</code> compares the object variable <code>money</code> of class <code>Person</code> to the static variable <code>SINGLETICKET_ADULT</code> of class <code>HslPrices</code>. The method <code>enoughMoneyForSingleTicket()</code> can be called only through an object reference. For instance:</p>

    <pre class="sh_java">
Person matti = new Person();

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
    </pre>

    <p>Note the naming convention! All <em>constants</em>, i.e. all variable which are provided with the definition final, are written with CAPITAL_LETTERS_AND_UNDERLINE_CHARACTERS.</p>

    <p>Static methods function analogously. For instance, the class <code>HslPrices</code> could <em>encapsulate</em> the variables and only provide <em>accessors</em>. We call accessors the methods which allow us to either read a variable value or to assign them a new one.</p>

    <pre class="sh_java">
public class HslPrices {
    private static final double SINGLETICKET_ADULT = 2.50;
    private static final double TRAMTICKET_ADULT = 2.50;

    public static double getSingleTicketPrice() {   // Accessor
        return SINGLETICKET_ADULT;
    }

    public static double getTramTicketPrice() {   // Accessor
        return TRAMTICKET_ADULT;
    }
}
    </pre>

    <p>In such cases, when we code a class such as <code>Person</code>, we can't call the variable straight, but we have to get it through the method <code>getSingleTicketPrice()</code>.</p>

    <pre class="sh_java">
public class Peson {
    private String name;
    private double money;
    // other object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.money &gt;= HslPrices.getSingleTicketPrice()) {
            return true;
        }

        return false;
    }

    // other methods regarding the class Person
}
    </pre>


    <p>Even though Java allows for static variable use, we do not usually require it. Often, using static methods causes problems with the program structure, because static variables are as inconvenient as <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">global variables</a>. <b>The only static variables we use in this course are constant, i.e. final!</b></p>

    <h3>Non-Static</h3>

    <p>Non-static methods and variables are related to objects. The object variables, or attributes, are defined at the beginning of the class. When an object is created with the <code>new</code> operator, we allocate storage space for all its object variables. The variable values are personal of the object, which means that every object receives personal variable values. Let us focus again on the class <code>Person</code>, which has the object variable <code>name</code> and <code>money</code>.</p>

    <pre class="sh_java">
public class Person {
  private String name;
  private double money;

  // other details
}
    </pre>

    <p>When we create a new instance of class <em>Person</em>, we also initialize its variables. If we do not initialize the reference-type variable <code>name</code>, it receives value <em>null</em>. Let us add the <em>constructor</em> and a couple of methods to our class <em>Person</em>.</p>

    <pre class="sh_java">
public class Person {
  private String name;
  private double money;

    // constructor
    public Person(String name, double money) {
        this.name = name;
        this.money = money;
    }

    public String getName() {
        return this.name;
    }

    public double getMoney() {
        return this.money;
    }

    public void addMoney(double amount) {
        if(amount &gt; 0) {
          this.money += amount;
        }
    }

    public boolean enoughMoneyForSigleTicket() {
        if(this.money &gt;= HslPrices.getSingleTicketPrice()) {
            return true;
        }

        return false;
    }
}
    </pre>

    <p>The constructor <code>Person(String name, double money)</code> creates a new Person object, and it returns its reference. The method <code>getName()</code> returns the reference to a <code>name</code> object, and the <code>getMoney()</code> method returns the original-type variable <code>money</code>. The method <code>addMoney(double amount)</code> receives as parameter an amount of money, and it adds it to the <code>money</code> object variable if the parameter's value is greater than 0.</p>

    <p>Object methods are called through their object reference. The following code example creates a new Person object, increases its money, and prints its name, at the end. Note that the method calls follow the pattern <code>objectName.methodName()</code></p>

    <pre class="sh_java">
Person matti = new Person("Matti", 5.0);
matti.addMoney(5);

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a single ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
    </pre>

    <p>The example prints "<code>I'll buy a single ticket.</code>"</p>

    <h4>Class Methods</h4>

    <p>Non-static class methods can be also called without specifying the object which indicates the class. In the following example, the <code>toString()</code> method points to the class <code>Person</code>, which calls the object method <code>getName()</code>.</p>

    <pre class="sh_java">
public class Person {
    // earlier written content

    public String toString() {
        return this.getName();
    }
}
    </pre>

    <p>The <code>toString()</code> method calls the class method <code>getName()</code>, which belongs to the object in question. The <code>this</code> prefix emphasizes that the call refers precisely to this object.</p>

    <p>Non-static methods can also call static methods, that is the class-specific ones. On the other hand, static methods can not call non-static methods without a reference to the object itself, which is essential to retrieve the object information.</p>


    <h4>A Variable within a Method</h4>

    <p>The variables which are defined inside a method are auxiliary variables used during the method execution, and they are not to be confused with object variables. The example below shows how a local variable is created inside a method. The <code>index</code> variable exists and is accessible only during the method execution.</p>

    <pre class="sh_java">
public class ... {
    ...

    public static void printTable(String[] table) {
        int index = 0;

        while(index &lt; table.length) {
            System.out.println(table[index]);
            index++;
        }
    }
}
    </pre>

    <p>In the <code>printTable()</code> method, we create the auxiliary variable <code>index</code> which we use to parse the table. The variable <code>index</code> exists only during the method execution.</p>


    <div class="tehtavat">
      <div class="tehtava">
        <h3>Thing, Suitcase, and Container</h3>

        <p>In these exercises, we create the classes <code>Thing</code>, <code>Suitcase</code>, and <code>Container</code>, and we train to use objects which contain other objects.</p>

        <h4 class="req">Class Thing</h4>

        <p>Create the class <code>Thing</code> whose objects can represent different kinds of things. The information to store are the thing's name and weight (kg).</p>

        <p>Add the following methods to your class:</p>

        <ul><li>A construsctor, which is given the thing's name and weight as parameter</li>
          <li><code>public String getName()</code>, which returns the thing's name</li>
          <li><code>public int getWeight()</code>, which returns the thing's weight</li>
          <li><code>public String toString()</code>, which returns a string in the form "name (weight kg)"</li>
        </ul><p>Below, you find an example of how to use the class:</p>

        <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);

        System.out.println("Book name: " + book.getName());
        System.out.println("Book weight: " + book.getWeight());

        System.out.println("Book: " + book);
        System.out.println("Mobile: " + mobile);
    }
}
        </pre>

        <p>The program output should look like the following:</p>

        <pre>
Book name: Happiness in Three Steps
Book weight: 2
Book: Happiness in Three Steps (2 kg)
Mobile: Nokia 3210 (1 kg)
        </pre>

        <h4 class="req">Class Suitcase</h4>

        <p>Create the class <code>Suitcase</code>. <code>Suitcase</code> has <code>things</code> and a maximum weight limit, which defines the greatest total allowed weight of the things contained within the <code>Suitcase</code> object.</p>

        <p>Add the following methods to your class:</p>

        <ul><li> A constructor, which is given a maximum weight limit</li>
          <li><code>public void addThing(Thing thing)</code>, which adds the <code>thing</code> in the parameter to your suitcase. The method does not return any value.</li>
          <li><code>public String toString()</code>, which returns a string in the form "x things (y kg)"</li>
        </ul><p>The <code>things</code> are saved into an <code>ArrayList</code> object:</p>

            <pre class="sh_java">
ArrayList&lt;Thing&gt; things = new ArrayList&lt;Thing&gt;();
            </pre>

            <p>The class <code>Suitcase</code> has to make sure the thing's weight does not cause the total weight to exceed the maximum weight limit. The method <code>addThing</code> should not add a new thing if the total weight happens to exceed the maximum weight limit.</p>

            <p>Below, you find an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in three steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase suitcase = new Suitcase(5);
        System.out.println(suitcase);

        suitcase.addThing(book);
        System.out.println(suitcase);

        suitcase.addThing(mobile);
        System.out.println(suitcase);

        suitcase.addThing(brick);
        System.out.println(suitcase);
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
0 things (0 kg)
1 things (2 kg)
2 things (3 kg)
2 things (3 kg)
            </pre>

            <h4>Language Check</h4>

            <p>"0 things" or "1 things" is not really proper English – it would be better to say "empty" or "1 thing". Implement this change in the class <code>Suitcase</code>.</p>

            <p>Now, the output of the previous program should look like the following:</p>

            <pre>
empty (0 kg)
1 thing (2 kg)
2 things (3 kg)
2 things (3 kg)
            </pre>

            <h4 class="req">Every Thing</h4>

            <p>Add the following methods to <code>Suitcase</code>:</p>

            <ul><li> <code>printThings</code>, which prints out all the <code>things</code> inside the suitcase</li>
              <li> <code>totalWeight</code>, which returns the total weight of the <code>things</code> in your suitcase</li>
            </ul><p>Below, there is an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase suitcase = new Suitcase(10);
        suitcase.addThing(book);
        suitcase.addThing(mobile);
        suitcase.addThing(brick);

        System.out.println("Your suitcase contains the following things:");
        suitcase.printThings();
        System.out.println("Total weight: " + suitcase.totalWeight() + " kg");
    }
}
            </pre>

            <p>The program output should now look like the following:</p>

            <pre>Your suitcase contains the following things:
Happiness in Three Steps (2 kg)
Nokia 3210 (1 kg)
Brick (4 kg)
Total weight: 7 kg
            </pre>


            <p>Modify your class also so that you use only two object variables. One contains the maximum weight, the other is a list with the things in your suitcase.</p>

            <h4 class="req">The heaviest Thing</h4>

            <p>Now, add the method <code>heaviestThing</code> to your class <code>Suitcase</code>, which returns the thing which weighs the most. If there are more than one <code>thing</code> with the same weight, the method can return either one. The method has to return an object reference. If the suitcase is empty, the method returns <em>null</em>.</p>

            <p>Here is an usage example of the class:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase suitcase = new Suitcase(10);
        suitcase.addThing(book);
        suitcase.addThing(mobile);
        suitcase.addThing(brick);

        Thing heaviest = suitcase.heaviestThing();
        System.out.println("The heaviest thing: " + heaviest);
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
The heaviest thing: Brick (4 kg)
            </pre>

            <h4 class="req">Container</h4>

            <p>Create the class <code>Container</code>, which has the following methods:</p>

            <ul><li> a constructor which is given the maximum weight limit</li>
              <li> <code>public void addSuitcase(Suitcase suitcase)</code>, which adds the suitcase as a parameter to the container</li>
              <li> <code>public String toString()</code> which returns a string in the form "x suitcases (y kg)"</li>
            </ul><p>Store the suitcase with a suitable <code>ArrayList</code> construction.</p>

            <p>The class <code>Container</code> has to make sure the <code>thing</code>'s total weight does not overcome the maximum weight limitation. The method <code>addSuitcase</code> should not add a new suitcase if the total weight happens to exceed the maximum weight limit.</p>

            <p>Below, there is an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase tomsCase = new Suitcase(10);
        tomsCase.addThing(book);
        tomsCase.addThing(mobile);

        Suitcase georgesCase = new Suitcase(10);
        georgesCase.addThing(brick);

        Container container = new Container(1000);
        container.addSuitcase(tomsCase);
        container.addSuitcase(georgesCase);

        System.out.println(container);
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
2 suitcases (7 kg)
            </pre>

            <h4 class="req">The Container Contents</h4>

            <p>Add the method <code>public void printThings()</code> to your <code>Container</code>; the method prints out all the things inside the container's suitcases.</p>

            <p>Below is an example of how the class can be used:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Thing book = new Thing("Happiness in Three Steps", 2);
        Thing mobile = new Thing("Nokia 3210", 1);
        Thing brick = new Thing("Brick", 4);

        Suitcase tomsCase = new Suitcase(10);
        tomsCase.addThing(book);
        tomsCase.addThing(mobile);

        Suitcase georgesCase = new Suitcase(10);
        georgesCase.addThing(brick);

        Container container = new Container(1000);
        container.addSuitcase(tomsCase);
        container.addSuitcase(georgesCase);

        System.out.println("There are the following things in the container suitcases:");
        container.printThings();
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
There are the following things in the container suitcases:
Happiness in Three Steps (2 kg)
Nokia 3210 (1 kg)
Brick (4 kg)
            </pre>

            <h4>A Lot of Bricks</h4>

            <p>Let's check that our container works fine and we can still not exceed the maximum weight limit. In the <code>Main</code> class, create the method <code>public static void addSuitcasesFullOfBricks(Container container)</code>, which adds 100 suitcases into the container it receives as parameter; there is one brick in each suitcase. The bricks weight will then increase by one each time until the weight becomes 100 kg.</p>

            <p>The program body is the following:</p>

            <pre class="sh_java">
public class Main {
    public static void main(String[] Container) {
        Container container = new Container(1000);
        addSuitcasesFullOfBricks(container);
        System.out.println(container);
    }

    public static void addSuitcasesFullOfBricks(Container container) {
        // adding 100 suitcases with one brick in each
    }
}
            </pre>

            <p>The program output should look like the following:</p>

            <pre>
44 suitcases (990 kg)
            </pre>

          </div>
        </div>

        <h2 id="hashmap">HashMap</h2>

        <p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">HashMap</a> is one of Java's most useful data structures. The idea behind HashMap is we define an index for an object key - a unique value, for instance a social security number, a student number, or a phone number. We call <em>hashing</em> the process of changing a key into an index, or simply to define an index. The hashing happens thanks to a particular function which makes sure that we get always the same index with a known key.</p>

        <p>Adding and retrieving items based on the keys allows for a particularly quick search process. Instead of parsing the table items one by one (in the worst case we would have to go through all the items), and instead of looking for a value with a binary search (in which case we would have to go through a number of items which would depend on the logarithm of the table size), we can look at only one table index and check whether a value is mapped to that index.</p>

        <p>HashMap uses the <code>Object</code> class <code>hashCode()</code> method to find a key value. Every HashMap subclass will <em>inherit</em> the <code>hashCode()</code> method. However, we will not go deep into HashMap workings in this course. We will return to inheritance in week 10.</p>


        <p>Java's <code>HashMap</code> class encapsulates - or hides - the way it works, and it returns made-up methods ready to use.</p>

        <p>When we create a HashMap we need two <em>type parameters</em>, a type for the key variable, and a type for the stored object. The following example uses a <code>String</code>-type object as key, and a <code>String</code>-type object as the stored object.</p>


        <pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
        </pre>

        <pre>
Yksi
Kaksi
null
null
        </pre>


        <p>In the example, we create a HashMap where both the key and the stored object are strings. We add information to the HashMap with the <code>put()</code> method, which receives the references to the key and to the stored object as parameter. The method <code>get()</code> returns either the reference to the key given as parameter or a <code>null</code> value in case the key was not found.</p>

        <p>Each key is mapped to one value, within the HashMap. If we store a new value with an already existing key, the old value is lost.</p>

        <pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");
numbers.put("One", "Uno");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
        </pre>

        <p>Because the key "<code>One</code>" is assigned a new value, the print output of the example is like the following.</p>

        <pre>
Uno
Kaksi
null
null
        </pre>

        <div class="tehtavat">
          <div class="tehtava">
            <h3>Nicknames</h3>

            <p>Create a <code>HashMap&lt;String,String&gt;</code> object in the <code>main</code> method. Store the following people's names and nicknames into the HashMap, the name being the key and the nickname its value. Use only lower case letters.</p>

            <ul><li>matti's nickname is mage</li>
              <li>mikael's nickname is mixu</li>
              <li>arto's nickname is arppa</li>
            </ul><p>Then, retrieve mikael's nickname and print it.</p>

            <p>The tests require you write lower case names.</p>

          </div>
        </div>
        <h3 id="kirjastotietokanta">Book Search through HashMap</h3>

        <p>Let us go deeper into HashMap workings with the help of the following example. Books can be retrieved based on their name, which acts as book key. If we find a book for the given name, we obtain the respective reference, as well as the book details. Let us create the example class <code>Book</code>, which has a name and the book contents as object variables.</p>

        <pre class="sh_java">
public class Book {
    private String name;
    private String contents;
    private int publishingYear;

    public Book(String name, int publishingYear, String contents) {
        this.name = name;
        this.publishingYear = publishingYear;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    public void setPublishingYear(int publishingYear) {
        this.publishingYear = publishingYear;
    }

    public String getContents() {
        return this.contents;
    }

    public void setContents(String contents) {
        this.contents = contents;
    }

    public String toString() {
        return "Name: " + this.name + " (" + this.publishingYear + ")\n"
                + "Contents: " + this.contents;
    }
}
        </pre>

        <p>In the following example, we create a HashMap which makes use of the book name - a String-type object - and stores the references which point to <code>Book</code>-objects.</p>

        <pre class="sh_java">
HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
        </pre>

        <p>The HashMap above has a <code>String</code> object as key. Let us extend our example so that we would add two books to our book collection, <code>"Sense and Sensibility"</code> and <code>"Pride and Prejudice"</code>.</p>

        <pre class="sh_java">
Book senseAndSensibility = new Book("Sense and Sensibility", 1811, "...");
Book prideAndPrejudice = new Book("Pride and Prejudice", 1813, "....");

HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
bookCollection.put(senseAndSensibility.getName(), senseAndSensibility);
librabookCollectionry.put(prideAndPrejudice.getName(), prideAndPrejudice);
        </pre>

        <p>Books can be retrieved from the book collection based on their name. A search for the book <code>"Persuasion"</code> does not return a corresponding entry, in which case the HashMap returns a <code>null</code> reference. However, the book "Pride and Prejudice" was found.</p>

        <pre class="sh_java">
Book book = bookCollection.get("Persuasion");
System.out.println(book);
System.out.println();
book = bookCollection.get("Pride and Prejudice");
System.out.println(book);
        </pre>

        <pre>
null

Name: Pride and Prejudice (1813)
Contents: ...
        </pre>

        <p>HashMaps are useful when we know the key to use for our search. Keys are always unique, and it is not possible to store more than one object together with one key alone. The object which we store can still be a <em>list</em> or another HashMap, of course!</p>

        <h3 id="kapseloitu_kirjasto">Library</h3>

        <p>The problem with the book collection above is that we must remember the correct book name when we search for it, character by character. Java built-in <code>String</code> class provides us the tools for this. The <code>toLowerCase()</code> method turns a string's characters to lower case, and the <code>trim()</code> method deletes the white spaces at the beginning and at the end of the string. Computer users tend to write white spaces at the beginning or end of a text, involuntarily.</p>

        <pre class="sh_java">
String text = "Pride and Prejudice ";
text = text.toLowerCase(); // the text is now "pride and prejudice "
text = text.trim() // the text is now "pride and prejudice"
        </pre>

        <p>Let us create the the class <code>Library</code>, which encapsulates a HashMap containing books, and allows for book search regardless of its spelling. Let us add the methods <code>addBook(Book book)</code> and <code>removeBook(String bookName)</code> to our <code>Library</code> class. It's already clear that we would need various different methods to clean a string. Therefore, we can create a separate method called <code>private String stringCleaner(String string)</code>.</p>

        <pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public void addBook(Book book) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(name)) {
            System.out.println("The book is already in the library!");
        } else {
            collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
        </pre>
        <p>We implement our search functionality so that we can retrieve a book using a hash algorithm based on the book name.</p>

        <pre class="sh_java">
    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }
        </pre>

        <p>The method above returns the wanted book when this is found, otherwise it returns a <code>null</code> value. We can also also go through all the collection keys one by one, and look for the beginning characters of the book's name. In this way, we would actually fail to capitalise on HashMap performance speed because, in the worst case, we would need to go through all the book names. Search based on the beginning characters of a string is possible through the <code>keySet()</code> method. The <code>keySet()</code> method returns a set of keys, which can be parsed with the <code>for each</code> loop.</p>

        <pre class="sh_java">
    public Book getBookUsingItsBeginningCharacters(String beginning) {
        beginning = stringCleaner(beginning);

        for (String key: this.collection.keySet()) {
            if (key.startsWith(beginning)) {
                return this.collection.get(key);
            }
        }

        return null;
    }
        </pre>

        <p>Let's leave the method above out of our library for now. Our library is still lacking an essential feature concerning book addition. Let us create the method <code>public ArrayList&lt;Book&gt; bookList()</code>, which returns a list of the books in our library. The method <code>bookList()</code> makes use of the <code>values()</code> method, which is provided by HashList. The <code>values()</code> method returns a set of our library books, which can be given as parameter to the constructor of an <code>ArrayList</code> class.</p>

        <pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }

    public void addBook(Book kirja) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(name)) {
            System.out.println("The book is already in the library!");
        } else {
            this.collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    public ArrayList&lt;Book&gt; bookList() {
        return new ArrayList&lt;Book&gt;(this.collection.values());
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
        </pre>

        <p>Among the programming principles, there is the so called <em>DRY</em> principle (Don't Repeat Yourself), according to which we try to avoid having code repeat in different places. Turning a string to lower case, and its <em>trimming</em> - removing white spaces from the beginning and the end of a string - would have ocurred several different places without the <code>stringCleaner()</code> method. We might hardly notice we are repeating the same code as we are writing. It is only afterwards we may see the repeated code has snuck in there. That the repetition happens is not in itself bad, however. The most important thing is that we clean our code as soon as we notice the need.</p>


        <h3>Original-Type Variables in a HashMap</h3>

        <p>Both HashMap keys and stored objects are reference-type variables. If we want to use an original-type variable as key or stored value, we can use their reference-type equivalent. Some are introduced below.</p>

        <p>
			</p><table><tr><th>Original-type</th>
					<th>Reference-type equivalent</th>
				</tr><tr><td>int</td>
					<td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td>
				</tr><tr><td>double</td>
					<td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" target="_blank">Double</a></td>
				</tr><tr><td>char</td>
					<td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Character.html" target="_blank">Character</a></td>
				</tr></table><p>In fact, Java automatically encapsulates original-type values and translates them into reference-type values when needed. Even though the number <code>1</code> is an original-type variable, it can be used as an <code>Integer</code> key directly in the following way.</p>

            <pre class="sh_java">
HashMap&lt;Integer, String&gt; table = new HashMap&lt;Integer, String&gt;();
table.put(1, "Be!");
            </pre>

            <p>In Java, the automatic translation of original-type variables into reference-type ones is called <em>auto-boxing</em>, i.e. allocation into a slot. The same process also works in the opposite way. We can create a method which returns a HashMap containing an Integer. In the following example, the automatic translation happens inside the method <code>addTwitch</code>.</p>


            <pre class="sh_java">
public class TwitchRegister {
    private HashMap&lt;String, Integer&gt; twitched;

    public NumberBookkeeping() {
        this.twitched = new HashMap&lt;String, Integer&gt;();
    }

    public void addTwitch(String name, int number) {
        this.twitched.put(name, number);
    }

    public int lastTwitch(String name) {
        this.twitched.get(name);
    }
}
            </pre>

            <p>Even though the HashMap contains Integer objects, Java can also translate certain reference-type variables into their original-type equivalent. For instance, <code>Integer</code> objects can be translated into <code>int</code> values, if needed. However, this can be misleading! If we try to translate a null reference into a number, we receive the <em>java.lang.reflect.InvocationTargetException</em> error. When we make use of this automatic translation, we have to be sure that the value we want to translate is not null. The above <code>lastTwitch</code> method must be fixed in the following way.</p>

            <pre class="sh_java">
    public int lastTwitch(String name) {
        if(this.twitched.containsKey(name) {
            return this.twitched.get(name);
        }

        return 0;
    }
            </pre>



            <div class="tehtavat">
              <div class="tehtava">
                <h3>Promissory Note</h3>

                <p>Create the class <code>PromissoryNote</code> with the following functionality:</p>

                <ul><li> the constructor <code>public PromissoryNote()</code> creates a new promissory note</li>
                  <li> the method <code>public void setLoan(String toWhom, double value)</code> which stores the information about loans to specific people.</li>
                  <li> the method <code>public double howMuchIsTheDebt(String whose)</code> which returns the entity of the debt held by the parameter <code>person</code></li>
                </ul><p>The class can be used in the following way:</p>

                <pre class="sh_java">
  PromissoryNote mattisNote = new PromissoryNote();
  mattisNote.setLoan("Arto", 51.5);
  mattisNote.setLoan("Mikael", 30);

  System.out.println(mattisNote.howMuchIsTheDebt("Arto"));
  System.out.println(mattisNote.howMuchIsTheDebt("Joel"));
                </pre>

                <p>The example above would print:</p>

                <pre>
51.5
0
                </pre>

                <p>Be careful in a situation where you ask for the debt of a person who hasn't got debts. Go back to the final example of section 36.3, if you need!</p>

                <p>Attention! The promissory note does not need to take into account old loans. When you set a new debt to a person who has an old one, the old one is canceled.</p>

                <pre class="sh_java">
  PromissoryNote mattisNote = new PromissoryNote();
  mattisNote.setLoan("Arto", 51.5);
  mattisNote.setLoan("Arto", 10.5);

  System.out.println(mattisNote.howMuchIsTheDebt("Arto"));
                </pre>

                <pre>
10.5
                </pre>
              </div>
              <div class="tehtava">
                <h3>Dictionary</h3>

                <p>In this exercise, we implement a dictionary which can be used to retrieve the English translation of Finnish words. We implement our dictionary using the <code>HashMap</code> data structure.</p>

                <h4 class="req">Class Dictionary</h4>

                <p>Create a class called <code>Dictionary</code>. The class has the following methods:</p>

                <ul><li> <code>public String translate(String word)</code>, returning the translation of its parameter. If the word is unknown, it returns <em>null</em>.</li>
                  <li> <code>public void add(String word, String translation)</code>, adding a new translation to the dictionary</li>
                </ul><p>Implement the class Dictionary so that it contained only one object variable, a <code>HashMap</code> data structure.</p>

                <p>Test your Dictionary:</p>

                <pre class="sh_java">
    Dictionary dictionary = new Dictionary();
    dictionary.add("apina", "monkey");
    dictionary.add("banaani", "banana");
    dictionary.add("cembalo", "harpsichord");

    System.out.println(dictionary.translate("apina"));
    System.out.println(dictionary.translate("porkkana"));
                </pre>

                <pre>
monkey
null
                </pre>

                <h4>Amount of Words</h4>

                <p>Add the method <code>public int amountOfWords()</code>, which returns the amount of words in the dictionary.</p>

                <pre class="sh_java">
    Dictionary dictionary = new Dictionary();
    dictionary.add("apina", "monkey");
    dictionary.add("banaani", "banana");
    System.out.println(dictionary.amountOfWords());

    dictionary.add("cembalo", "harpsichord");
    System.out.println(dictionary.amountOfWords());
                </pre>


                <pre>
2
3
                </pre>

                <h4>Listing All Words</h4>

                <p>Add the method <code>public ArrayList&lt;String&gt; translationList()</code> to your dictionary, returning strings which stand for a content list of your dictionary in the form <i>key = value</i>.</p>

                <pre class="sh_java">
    Dictionary dictionary = new Dictionary();
    dictionary.add("apina", "monkey");
    dictionary.add("banaani", "banana");
    dictionary.add("cembalo", "harpsichord");

    ArrayList&lt;String&gt; translations = dictionary.translationList();
    for(String translation: translations) {
        System.out.println(translation);
    }
                </pre>

                <pre>
banaani = banana
apina = monkey
cembalo = harpsichord
                </pre>

                <p><strong>Hint:</strong> you can go through all HashMap keys using the method <code>keySet</code> in the following way:</p>

                <pre class="sh_java">
    HashMap&lt;String, String&gt; wordPairs = new HashMap&lt;String, String&gt;();

    wordPairs.put("monkey", "animal");
    wordPairs.put("South", "compass point");
    wordPairs.put("sauerkraut", "food");

    for ( String key : wordPairs.keySet() ) {
        System.out.print( key + " " );
    }

    // prints: monkey South sauerkraut
                </pre>



                <h4 class="req">The Beginning of a Text User Interface</h4>

                <p>In this exercise, we also train creating a text user interface. Create the class <code>TextUserInterface</code>, with the following methods:
                </p><ul><li> the constructor <code>public TextUserInterface(Scanner reader, Dictionary dictionary)</code></li>
                  <li> <code>public void start()</code>, which starts the interface.</li>
                </ul><p>The text user interface stores into two object variables the reader and dictionary it has received as constructor parameters. You don't need other object variables.
                <strong>
                  The user input must be read using the reader object received as constructor parameter! The translations also have to be stored into the dicitonary object received as constructor parameter. The text user interface must not create new objects itself!
                </strong>
                </p>

                <p><strong>Attention:</strong> This means <strong>The text user interface must not create a scanner itself</strong> but it must use the scanner received as parameter to read the user input!</p>

                <p>At the beginning, in the text user interface must only have the command <code>quit</code>, to quit the text user interface. If the user inputs something else, we print "Unknown statement".</p>

                <pre class="sh_java">
    Scanner reader = new Scanner(System.in);
    Dictionary dict = new Dictionary();

    TextUserInterface ui = new TextUserInterface(reader, dict);
    ui.start();
                </pre>

                <pre>
Statement:
  quit - quit the text user interface

Statement: <font color="red">help</font>
Unknown statement

Statement: <font color="red">quit</font>
Cheers!
                </pre>

                <h4 class="req">Adding and Translating Words</h4>

                <p>Add the methods <code>add</code> and <code>translate</code> to your text user interface. The command <code>add</code> asks for a word pair from the user and adds them to the dictionary. The command <code>translate</code> asks a word from the user and it prints the translation.</p>

                <pre class="sh_java">
    Scanner reader = new Scanner(System.in);
    Dictionary dict = new Dictionary();

    TextUserInterface ui = new TextUserInterface(reader, dict);
    ui.start();
                </pre>

                <pre>
Statements:
  add - adds a word pair to the dictionary
  translate - asks a word and prints its translation
  quit - quits the text user interface

Statement: <font color="red">add</font>
In Finnish: <font color="red">porkkana</font>
Translation: <font color="red">carrot</font>

Statement: <font color="red">translate</font>
Give a word: <font color="red">porkkana</font>
Translation: carrot

Statement: <font color="red">quit</font>
Cheers!
                </pre>

              </div>
            </div>

            <h2>Towards Automatic Tests</h2>

            <p>Testing a program manually is a hopeless burden. It is possible to automate inputs by setting up a string as a Scanner object parameter. The example below shows how it is possible to test automatically the program above.</p>

            <pre class="sh_java">
    String input = "translate\n" + "monkey\n"  +
                   "translate\n" + "cheese\n" +
                   "add\n"  + "cheese\n" + "juusto\n" +
                   "translate\n" + "cheese\n" +
                   "quit\n";

    Scanner reader = new Scanner(input);
    Dictionary dictionary = new Dictionary();

    TextUserInterface ui = new TextUserInterface(reader, dictionary);
    ui.start();
            </pre>

            <p>The print output contains only the program output, and not the user commands.</p>

            <pre>
Commands:
  add - adds a word couple to the dictionary
  translate - asks for a word and prints its translation
  quit - stops the user interface

Command: Give word: Unknown word!

Command: Give word: Unknown word!

Command: In Finnish: Translation:
Command: Give word: Translation: juusto

Command: Cheers!
            </pre>

            <p>Giving a string to a Scanner class is a way to replace the String inputs given through the keyboard. The contents of the String variable <code>input</code> "simulates" the user input. <code>\n</code> denotes a line break. Each single part of the <code>input</code> variable which ends with a line break corresponds to one nextLine() input.</p>

            <p>It is easy to change the text input, and we can add new words to our dictionary in the following way:</p>

            <pre class="sh_java">
    String input = "add\n"  + "cheese\n" + "juusto\n" +
                   "add\n"  + "bier\n" + "olut\n" +
                   "add\n"  + "book\n" + "kirja\n" +
                   "add\n"  + "computer\n" + "tietokone\n" +
                   "add\n"  + "auto\n" + "car\n" +
                   "quit\n";
            </pre>

            <p>If you want to test again your program manually, change the Scanner object constructor parameter into <code>System.in</code>, i.e system input stream.</p>

            <p>The program functionality must be checked from the output pane, still. The result can still be confusing at the beginning, because the automatic input does not appear in the output pane at all.</p>

            <p>The final goal will be to also automate the testing the program's functionality, so that both testing the program and analising its output text would happen successfully in one click.</p>




            <h2>Java API</h2>

            <p>The Java programming language we use in our course is made of three things. The first is the program syntax and semantics: the way we define variables, the control flow, the variable and class structure, and their functionality. The second is JVM, i.e. <em>Java Virtual Machine</em>, used for running our programs. Our Java programs are translated into a <em>bytecode</em>, which can be run on whatever computer has JVM. We haven't dealt with program translation because the program environment does it on our behalf. Sometimes, if the program environtment does not work as expected we may have to choose <em>clean &amp; build</em>, which deletes the old source code and translates our program again. The third is API (<em>Application Programming Interface</em>), that is to say the program interface or standard library.</p>

            <p>API is a set of built-in classes specific of the programming language, which is provided to users for their own projects. For instance the casses <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, and <code>String</code> are all part of Java's build-in API. A description of the API of Java 7 can be found at the address <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. On the left side of the page we find a description of Java's built-in classes. If you look for the <code>ArrayList</code> class, you  find a link to <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, which shows the stucture, constructors, and methods of the class.</p>

            <p>NetBeans is able to show a class API, if needed. If you write a class name and add the relative import sentence, you can right click on the class name and and choose <em>Show Javadoc</em>. This opens the class API description in your browser.</p>

            <div class="tehtavat">

              <div class="tehtava">
                <h3>Airport</h3>

                <p>Every week, you will find one or more larger exercises, where you can design freely the program structure, the appearance of the user interface and the requred commands are predefined. The first exercise which you can design freely in Advanced Programming is <em>Airport</em>.</p>

                <p><b>Attention: you can create only one Scanner object so that your tests would work well. Also, do not use static variables, the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</b></p>

                <p>In the airport exercises we create an application to manage an airport, with its airplanes and flights. As far as the planes are concerned, we always know their ID and capacity. As for the flights, we know the plane used for the flight, the departure airport code (for instance <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) and the destination airport code (for instance <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>

                <p>There can be various different flights and planes. The same plane can also go on various different flights (various different routes). The application must offer two different panels. First, the airport worker inputs the flight and plane information to the system in the airport panel.</p>

                <p>When the user exits the airport panel, the user then proceeds to use the flight service. The flight service has three actions: printing planes, printing flights, and printing airplane information. In addition to this, the user can exit the application by choosing <code>x</code>. If the user inputs an invalid command, the command is asked again.</p>


                <pre>
Airport panel
--------------------

Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
&gt; <font color="red">1</font>
Give plane ID: <font color="red">HA-LOL</font>
Give plane capacity: <font color="red">42</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
&gt; <font color="red">1</font>
Give plane ID: <font color="red">G-OWAC</font>
Give plane capacity: <font color="red">101</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
&gt; <font color="red">2</font>
Give plane ID: <font color="red">HA-LOL</font>
Give departure airport code: <font color="red">HEL</font>
Give destination airport code: <font color="red">BAL</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
&gt; <font color="red">2</font>
Give plane ID: <font color="red">G-OWAC</font>
Give departure airport code: <font color="red">JFK</font>
Give destination airport code: <font color="red">BAL</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
&gt; <font color="red">2</font>
Give plane ID: <font color="red">HA-LOL</font>
Give departure airport code: <font color="red">BAL</font>
Give destination airport code: <font color="red">HEL</font>
Choose operation:
[1] Add airplane
[2] Add flight
[x] Exit
&gt; <font color="red">x</font>

Flight service
------------

Choose operation:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
&gt; <font color="red">1</font>
G-OWAC (101 ppl)
HA-LOL (42 ppl)
Choose action:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
&gt; <font color="red">2</font>
HA-LOL (42 ppl) (HEL-BAL)
HA-LOL (42 ppl) (BAL-HEL)
G-OWAC (101 ppl) (JFK-BAL)

Choose operation:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
&gt; <font color="red">3</font>
Give plane ID: <font color="red">G-OWAC</font>
G-OWAC (101 ppl)

Choose operation:
[1] Print planes
[2] Print flights
[3] Print plane info
[x] Quit
&gt; <font color="red">x</font>
                </pre>

                <p><strong>Attention:</strong> for the tests, it is essential that the <em>user interface</em> works <b>exactly</b> as displayed above. In fact, it is a good idea to copy-paste the menus printed by the above program into your code <em>exactly</em>. The tests do not require that your program should be prepared to deal with invalid inputs. This exercise is worth three single excercise points.</p>

                <p><em><strong>The program must start by executing the main method in the exercise layout.</strong></em></p>

                <p><b>Still another remark:</b> in order to make your tests work, your program has to create only one Scanner object. Also, avoid using static variables: the tests execute your program many different times, and the static variable values left from the previous execution would possibly disturb them!</p>
              </div>
            </div>
          </div>    </div>


      </div><!-- /inner -->

  </div><!-- /node-305 -->
        </div>


              </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block -->  </div>
</div>
  </div>
</div>
</div>
</div>
                                                                  </div><!-- /content-content -->
                                                              </div><!-- /content-inner-inner -->
                            </div><!-- /content-inner -->
                          </div><!-- /content-region-inner -->
                        </div><!-- /content-region -->

                        <div id="content-bottom" class="content-bottom row nested ">
<div id="content-bottom-inner" class="content-bottom-inner inner clearfix">

<div id="block-block-1" class="block block-block odd first last grid16-16">
  <div class="inner">
    <div class="corner-top"><div class="corner-top-right corner"></div><div class="corner-top-left corner"></div></div>
      	<div class="inner-wrapper">
      <div class="inner-inner">
                <div class="content clearfix">
          <div id="header-top-block">
<p class="rtecenter">
Help: <a href="https://riot.im/app/#/room/#mooc.fi:matrix.org">IRCnet/Matrix #mooc.fi </a>&nbsp;&nbsp; |  News: <a href="http://twitter.com/moocfi"><img src="/2013-oo-programming/resources/Twitter_Logo_Blue.png" height="50" style="vertical-align: middle;"></a><a href="http://www.facebook.com/Moocfi"><img src="/2013-oo-programming/resources/FB-f-Logo__blue_100.png" height="30" style="vertical-align: middle;"></a></p>
<p class="rtecenter">
<a href="http://www.cs.helsinki.fi">
<img alt="Helsingin yliopiston tietojenk&auml;sittelytieteen laitos" src="/2013-oo-programming/sites/mooc.cs.helsinki.fi/files/CS-logo-MOOC.jpg" width="400" style=" vertical-align: middle;" />&nbsp; </a></p>
	</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47575342-3', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');

</script>        </div>
      </div><!-- /inner-inner -->
	  </div><!-- /inner-wrapper -->
    <div class="corner-bottom"><div class="corner-bottom-right corner"></div><div class="corner-bottom-left corner"></div></div>
  </div><!-- /inner -->
</div><!-- /block --></div><!-- /content-bottom-inner -->
</div><!-- /content-bottom -->
                      </div><!-- /content-group-inner -->
                    </div><!-- /content-group -->

                                      </div><!-- /main-content-inner -->
                </div><!-- /main-content -->

                              </div><!-- /main-group-inner -->
            </div><!-- /main-group -->
          </div><!-- /main-inner -->
        </div><!-- /main -->
      </div><!-- /main-wrapper -->

      <!-- postscript-bottom row: width = grid_width -->

      <!-- footer row: width = grid_width -->

      <!-- footer-message row: width = grid_width -->
      <div id="footer-message-wrapper" class="footer-message-wrapper full-width">
        <div id="footer-message" class="footer-message row grid16-16">
          <div id="footer-message-inner" class="footer-message-inner inner clearfix">
                              <div id="footer-message-text" class="footer-message-text block">
<div id="footer-message-text-inner" class="footer-message-text-inner inner clearfix">
<br />
</div><!-- /footer-message-text-inner -->
</div><!-- /footer-message-text -->

          </div><!-- /footer-message-inner -->
        </div><!-- /footer-message -->
      </div><!-- /footer-message-wrapper -->

    </div><!-- /page-inner -->
  </div><!-- /page -->
  </body>
</html>
